##ME-2 script PMF_bs_6f8.ini Licence: me2keysealed.9102
% ##ME-2 script PMF_bs_6f8xx.ini  Licence:  \me2\me2key.key
% Copyright Pentti Paatero, Nov 2010, Feb 2014.
% Last modified by PP on          2014-03-03  ************************** 
  % ##ME-2  script PMF_bs_6f8xx.ini Licence:  me2sealer102.key
% Last modifications (newest shown last):
  
  % Changes Shelly made for BS-DISP work
%  1.  sortAcorr changed from 0 to 1
%  2.  changed a write statement for BSDISP output so that output from each
%      task has same number of lines.  Changed (//A) to (5//A) for lines
%      before "Factor sorting was enabled but not needed now"
%  3.  changed dispswap1 from 0.9 to 0.8 and dispswap2 from 0.5 to 0.3


%- Factor selection based on row types implemented in PMF_bs_4s4.ini.
%    In random rotational pulling, # of pulled AA ignores # of invalid
%    XX rows. Assuming that # of invalid rows will never be "large". 
%    FPEAK pulling has not yet been updated for taking into account 
%    factor selection!!!!!!!!!!!???????
  %- Optimized: execute equ> commands in the order of table elements
%    which is also the execution order during iteration. This 
%    minimizes main memory accesses during iteration. Important 
%    when solving large problems! (beginning with 4t2)

%*******************************************************************
  %- version 4t1 and following ones (4u2 etc) contain experimental AER
%    (= Air Echange Rate) modeling. These versions may not be part of
%    EPA PMF development path. However, the AER commands are kept
%    in the code so that only one development path is maintained.
%*******************************************************************
  
  %  DISP pulling has been successfully tested with simulation, 
%  both with A*B and with A*C*B models! (vers. 4w1)

%- In ME-2, the action of EM=-23 was improved. Version 4w1 of
%  this script has been updated so that the improved EM=-23 is
%  fully utilized. Now the normalizations happen with a specified
%  accuracy, up to 0.1%.  Version 4w2 also contains
%  convergence monitoring for EM=-20,-21

%- 4w16:  Improved displacement control for DISP. Much better
%  diagnostics in DISP output of CI's. Adjustable Q correction 
%  based on increase of number of constrained factor elements.
%  Summaries of CI lengths are computed and written.

%- 4w19:  Corrected the situation where dQ-controlled perturbation
%  (errestmode=-2) displaces one factor element to a value that is
%  larger than the norm target value bnorm (only in the ACB model)
%  This caused a normalization conflict with large Qaux values.
%  In the new version, up perturbations of normalized BB are limited 
%  by the value of bnorm. 

%- 4w20:  Stability of DISP estimation in certain specific situations 
%  was improved. In particular when 
%  - all elements of a row of best-fit BB are =0.
%  - there are locked or masked elements in BB or CC.
%  Minor bugs were corrected. Input of true factor matrices for
%  simulation is achieved by setting simu=3.1 (4.1) instead of 3 (4).

%- 4w24:  Implemented output of swapping counts, both for DISP and for BS.
%  For error estimation runs with ACB model, sets automatically
%  lower limit of C elements = 0.1*min(best_fit_C). This is necessary 
%  in order to prevent rare occasions when a C element obtains the value
%  0.0 (exactly). CC[jp]==0 would be a deadlock, the iteration cannot 
%  recover from it. 
%  - increased max-rec-lengths of data-dependent files to 20000.
%  This is currently the maximum allowed by ME-2.

%- 4w25: Action in error situations:
%  "Tentative factor swap" is detected if diagonal of T1 is < 0.5 x 
%  the corresponding T1 column maximum value.
%  2 or more such tentative factor swaps in T1 --> "probable swap"
%  Displacement (step) is cut short twice if probable swap is detected.
%  If probable swap repeats 3x, the swapped displacement is used as
%  basis of error estimate(s), swap indicator is set in result tables
%  "Bad gradient" is diagnosed if Q decreases with increasing displ.
%  Step is shortened max. 6 times in the hope of avoiding the bad 
%  gradient.   --- One persistent coding error corrected!

%- 5b1:  For BS, script evaluates and reports results of unpulled and 
%  pulled tasks separately if variable splitBSres = 2 (default is =1)     
%  Other values should not be used, no screening for legal values!
%  (modify initialization, on or near line # 921)
%
%- 5d1x: corrected the computation of largest and smallest
%  BS results: now the best-fit value does not appear in the table.
%- 5d2x: corrected bugs in handling splitBSres
%- 5d5 and 5d5x: writes in the main output file a list of 
%  such elements where DISP estimation is questionable because
%  highest dQmax is not reached. Name Errest.dat --> DISPest.dat

%- 5d7x: the normalization of A factors has been changed for 
%  the case when sample type coding is used, i.e. when numrowtyps>1.
%  Then the sum of factor values A[0,jp] is normalized to the #
%  of rows where factor jp is active.

%- 5d8x: modify factor resorting so that factors of different
%  types will not be exchanged when looking for best possible
%  correlation with first/best run.

%- 5d9x: modified formats with repeat counts so that a ghost
%  space will not appear after last item of the output list.
%  In this way, all Fortran versions will produce identical 
%  output.
%- 5d11x: requests version 1.332 of ME-2, contains a valid seal
%  for running under the EPA PMF public licence

%- the x in file name indicates that splitBSres=2 has been
%  specified in the .ini file, on or near line # 961
%  NOT POSSIBLE! ERRORS IN CODE!


% This version contains optional adaptation for non-GUI
% testing with Palookaville data. This option is chosen by
% using value=1 for the control parameter "modifcode".

% For the parametric model (AAM), std-dev are specified as 
% follows:
% The C1 and C3 coefficients for AAM equations are specified as 
% modelc1 and modelc3, input from file iniparams.txt
% errormodel is -5.

% May apply Bootstrap reweighting to AAM equations, in addition
% to reweighting XX equations. (Previously, XX were reweighted
% while all AAM equations were used at their "nominal" weights.)
% Now, AAM are reweighted if rewgxxm==1.

% Seal is valid for version 5a26 and following similar versions
% but not for version 6a1 and following

% PMF_bs_6a1 and following versions
%----------------------------------
%- changed all occasions of  erre  -->  disp, in upper and lower case
% Implemented errestmode=2, do all BS tasks without random pulling

% MINMAXFACT organization is clumsy, separate MIN and MAX to
% different slices (do later). At the same time, implement
% Bmerge{A[0], value, 'hi'} and Bmerge{A[0], value, 'lo'} 
% for inserting a value to a sorted block. Function value is
% the shifted-out element. -- not implemented yet

% This paragraph updated for version 6e1
% Implemented BS-DISP operations. -All- min and max estimates are now
% saved to array segments BSDISPRES[0,0,0,0,1] (min) and
% BSDISPRES[0,0,0,0,2] (max)
% During output, in last task, sorted values are saved to 
% BSDISPRES[0,0,0,0,2] so that first half of values are the 
% smallest 50% of min estimates. 
% Second half are the largest 50% of max estimates.

% 6b1: modified gradient cutting so that 5 _consecutive_ small-gradient
% callbacks are required. Must make the cutting value dependent on
% the smallest dQmax value!!!!!??????
% 6b2: in Dispnext, shortened the initial step length if it should be
% too long in comparison to initial factor value.

% 6c3: implement new A-column normalization method for BS resamples,
% so that scaling of B remains the same as in BS full-data fit.

% 6c4 and 6c5: 
% For BS with samplevari=2 & bsinitfact=1 (random starts),
% script computes the normalization coefficients introduced in 6c3,
% does not use them, but writes them to file BStoDISP.dat.
% Also, writes the normalization coefficients to file **.dat,
% as a table of (numtasks-1) rows, after all the usual output.

% 6c6: table of DISP failures enhanced with code numbers of failures
% -2 indicates bad gradient, 2 and 3 indicate swap of 2 or 3 factors
% 6c7: bad gradient "withdrawn" as an error situation.
%      Hence, -2 should not occur in table of DISP failures

% 6c8: write DISP results to separate files for each dQmax (same as BS-DISP)
%   Report swapped factors if 
%    - last (converged) disp had swap
%    - swap caused that disp was shortened so that some dQmax were not 
%      reached, even if last disp was non-swap
% 6c10: some bug corrections: new command for cross correlations
%      corrected and used
% 6c12: bug corrections
% 6c13: after-disp rejection of swapped or "bad" resamples implemented
%    in BS-DISP, dispbsOKn is the number of accepted resamples, 
%    to be written. 
% 6c15: clarified diagnostics in *.txt, more writing of regression tables
%       corrected handling of reject code that often was =0 even if swaps>1
%       corrected a minor bug in DISP: 
%    factor max of higher dQmax could be < same max at lower dQmax
%    and similarly for factor min --- both corrected.
% 6c16: corrected a long-time bug: BS-DISP did not perform up pulling
%       of any resamples, it only pulled down on full data. 
% 6d1: corrected a long-time bug: deepest drop in Q was not seen
% 6d2: introduced rejection of BS-DISP resample if Q (as seen from gradients)
%      drops by more that by (DISPDQMAX(dispdqlevs)+10)
%      Output counts of resample rejections because of the 3 reasons:
%      
% 6d3: Output format of BSCOUNTS changed I4 --> F6.2 in order to
%      be able to test bsmode=15 which produces fractional counts.
% 6e1: Computes and outputs estimates of F matrix so that after
%      scaling G to col-avg=1, scales F so that each column of F 
%      is scaled to sum=1 (sum=100?)  (in DISP and BS-DISP)
%      and collects low- and high-estimates of such scaled F
% 6e2: correcting bugs. Keeping bsmode for BS-DISP, for AAM weighting
% 6e3: clearer output of correlations of factors used for sorted
%      output regression table for all cases except varying-data simul.
%      mask correlations of forbidden sorting by using FSAMETYPE
%  N.B. Same masking not used yet for sorting/swaps based on regression ?????????????????
%      sorting out how to use bsmode, when to abort, when to reject
% 6e5: systematic rejection, using disprejsco and disprejthr.
%      including best-fit swaps in factor swap table, for all dQlevs
% 6e7: corrected bug that prevented tabulating results into summary 
%      tables about up displacements. New ini version:  161110


% For testing under GUI, change:     gui=0;  -->  gui=1;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
$skiplines

Extended 2-way factor analysis with parametric factors.
=======================================================
Application of Bootstrap sampling and pulling in order to 
determine the error limits of both the compositional factor 
elements (customarily called F) and the parametric factor
elements.

This script contains commands for both real data and for
simulations. In this way, the real program may be challenged
by simulated data, and its performance can be studied by
analyzing simulated data, where the true values are known.
The built-in simulations do not handle parametric variables,
however.

This script is primarily intended for use through the GUI
developed by EPA. The script can also be used so that the 
user creates the input files, including the control file
iniparams.txt, outside of the GUI. This requires more
skills in using the language of ME-2.

This documentary text within the script describes mainly
the customary bilinear model, without parametric factors. 
Additional information about the parametric model is in 
file Param_info_v4.txt or in later versions of the file.


Notation
--------
BS   = bootstrap
CI   = confidence interval
GUI  = Graphical User Interface  (of EPA PMF)
DISP = error estimation by dQ-controlled displacement of 
       factor elements

The column or "G" factors are denoted by A or AA
The rows of "F" factors are denoted by (columns of) B or BB 

A*B   = The usual PMF model (AA is normalized)
A*C*B = Modified PMF model: Both AA and BB are normalized,
        factor strengths are stored in CC factor elements.

The factor elements CC are formally present even in the
usual A*B model, but they are by definition equal to 1.0
in the A*B model.


Protection by the seal, modifications of the script
---------------------------------------------------
This script contains a seal code. This seal code 
allows that as long as the sealed part (= the whole section 
"equations") remains unmodified, the script can be executed 
under the public ME-2 licence that is distributed by the
EPA under the name EPA PMF. 

In the basic use of the script, no modifications of the 
script are needed. The GUI controls the operations 
by generating different versions of the file iniparams.txt. 
The script reads the file iniparams.txt whenever a ME-2 run 
is started. This reading sets values for different control 
variables of the script. As an example, the control variable 
"simu" gets the value 0 when the standard version of 
iniparams.txt is read. 

In advanced use, the script may be modified by the user
so that the sealed part remains intact. Such a script may
still be used together with the GUI if the interface 
operations remain compatible with the GUI. 

The script contains a large number of control variables
that may be modified by the advanced user. Modifications 
of these control variables should be performed early 
in the script, not later than immediately after the 
setting "em=-12;". 
If modifications appear necessary later in the script,
key values of such modifications should be collected
before the setting "em=-12;". In this way, scattered 
modifications in the body of the script can be avoided.
This enhances the reliability of the script in the long
run.

If the user owns a private (non-public) licence for 
using ME-2, then the script may be executed under such a 
licence:
Modify the first line of the script so that it points
to the non-public licence. In this case, even the sealed
part "equations" may be freely modified because then the 
seal is ignored.


Normalization
-------------
This script works so that weighted averages of A columns
are normalized to unity. The averaging weights are stored
in vector ANORMWG. In all situations, 
sum of ANORMWG is = n1.
 - In standard PMF, ANORMWG[0]=1, corresponding to an 
unweighted average of AA being normalized to unity.
 - In original standard BS, ANORMWG values are equal to sampling
counts. In this way, weighting exactly corresponds to
actually having multiple copies of multiply sampled rows
present in the replicated matrix XX.
 - In new version of BS, ANORMWG values are adjusted so that
for each column of A, the scaling of A and B remains invariant
of the resample. The adjustment is different for different 
columns of A.
 - In other situations, ANORMWG values are somehow 
derived from the sampling counts, see below.
If other normalization of A is needed in some applications,
it is necessary to recompute the desired normalization
in postprocessing or outside of this script.
** The built-in AA normalization should not be modified **
** inside the script, except in postprocessing section. **

A*B vs. A*C*B
In the modified model "A*C*B", BB factors are also 
normalized, so that factor strength for factor number jp is 
contained in factor element C[1,jp].
  "A*B": XX(i,j) = SUM_p AA(i,p) * BB(j,p)           + E(i,j)
"A*C*B": XX(i,j) = SUM_p AA(i,p) * CC(1,p) * BB(j,p) + E(i,j)
The default normalization for BB for non-simulation runs is 
to normalize the column sum of BB factor elements to sum=1.

Feb 2007: Dynamic updating of normalization strengths was 
introduced, using EM=-23. The value of normc1 is not used
for anything at all.


The extended model, fitting with parametric factors
---------------------------------------------------
The control variable "numpf" determines whether the
extended model is fitted:
- numpf=0   
  The basic 2-way model, with error analysis of composition 
  factors (BB) based on BS and random pulling (see below)
                 
- numpf=k   (k=1 or 2 or 3)                 
  The basic 2-way model is extended by also fitting a 
  parametric model, containing k ordinary parametric factors
  plus one or more yes/no parametric factors.
  Error analysis covers both the compositional factors
  and also the parametric factors.

Detailed information about the parametric model is given
in file Param_info_v4.txt or in later versions of the file.


Analysis of real (non-simulated) data
-------------------------------------
This script is used for analyzing real data by setting
"simu"=0 and reading the data matrix XX from a file.
Then different variants of the run are controlled as follows:
- numpf=0:  |  Both cases 
- numpf>0:  |  .. are possible. 
- "contrun"=0: Iteration is started from random values.
Then typically use numtasks=20 in order to find the best 
solution.
- contrun=1: Iteration is started from values read from
a file. The result file from a previous run (with contrun=0) 
can be used as such. The variable "numoldsol" should indicate
the position of the desired solution in the file: numoldsol=1
indicates that the first computed solution is to be used as 
the starting point, numoldsol=2: the second solution, etc.
- - "numtasks"=1: An ordinary PMF run is performed, 
continuing from a previous result. This is useful e.g. in 
order to study the effect of "manually" pulling down selected 
factor elements.
- - numtasks>>1, errestmode=1   (earlier the only option) and
  - numtasks>>1, errestmode=2 
First, an ordinary PMF computation is performed 
so that an (improved) best-fit solution is obtained. 
Then, a number of bootstrap replications are computed.
  - if errestmode=2, then each BS replication is computed once,
    without random pulling of AA elements. This method is
    mostly intended as the first step of BS-DISP
  - if errestmode=1, then each BS replication is computed twice. 
    This was the only BS method prior to June 2010.
    First computation is without pulling of AA elements. 
    Second replication, with the same sampling counts, is 
    enhanced by random pulling of AA elements. 
Bootstrap sampling counts may be read from the file 
bscounts.txt. If used, this file must be prepared in advance 
by the GUI.


Analysis of simulated data
--------------------------
With simu>0, this script performs a simulation/demonstration 
run with randomly generated true factors and random noise 
added into the simulated matrix XX. In simulations,
numpf is always =0.
The control variables simu and contrun have the following 
options. However, in BS computations, the definition of the 
starting point (= random/best/true) can be overriden by 
setting a non-zero value (1/2/3) to control variable 
"bsinitfact".

- contrun=0: iteration is started from a set of random 
factor values (different from the random "true factors")
- contrun=2: iteration is started from true factor values
- simu=3 & contrun=2 & numtasks>>1 & errestmode>0: 
The script simulates "true factors" and XX once, before 
computing task 1. In task 1, a best-fit solution is 
computed, using all data. In follow-up tasks, BS replications 
or DISP perturbations are computed. After the last task, 
summary information is written so that the success of the 
analysis can be estimated.
- simu=4 & contrun=0: The script creates "true factors" and 
XX once, before computing task 1. This XX is then fitted 
in each task, each time starting from a new set of random 
values.
- simu=1 & simu=2: these alternatives have not been tested.
For details, see the definition of variable "simu".


BS enhanced by random pulling of A factors
------------------------------------------
The script performs bootstrap (BS) computations in the
following two cases if :
 - simu==3 & numtasks>>1 & errestmode=1         
        (analysis of simulated data) 
 - simu==0 & contrun==1 & numtasks>1 & errestmode=1  
        (analysis of real data) 
BS is based on sampling counts, specifying how many times
each row of X is sampled. 
The sampling counts are read from a file (if readbscnts=1), 
or the script generates the counts (if readbscnts=0). 
Each BS replication uses one set of sampling count values.
The i'th sampling count number indicates how many times 
row i of X is sampled in a BS replication. Technically, sampling
is implemented by reweighting the equations.
Sampling/reweighting is applied also to the parametric equations
(the AAM equations), if parametric factors are used and if the
control variable rewgxxm is =1.

The script contains a device for randomly pulling A factors in 
order to explore the rotational ambiguity when doing BS.
The pulling is towards "anchors" at 3 units below and 3 units 
above the best-fit value of A factors. The pulling strength 
parameter pullc1 (= C1 of the pulling equations) is specified 
by the user. In testing with 100x15 data, pulling strength 
pullc1=2.0 appeared a reasonable value.
Pulling can only be applied to such rows of A that correspond 
to sampled rows of XX, i.e. rows for which the sampling count 
is >0. Only one element on any row of A can be pulled. 
Exceptionally large elements of A (i.e. A elements > 10.0) 
are not pulled at all.

In the first EPA version, pulling is not yet considered as 
well-tested. For this reason, a weak pulling strength is
recommended: pullc1>=2.0. 
Randomly chosen elements of A factors are pulled. The number of
values to be pulled up (and also, the number to be pulled down) 
is the smaller of the values np*np and 0.08*n1.

The bootstrap sampling counts can be generated by the following
matlab commands (example is for 80 replications, 100 rows):
  ind=round(99.99*rand(80,100)+0.5001); sample=zeros(80,100);
for ii=1:80; for jj=1:100; 
sample(ii,ind(ii,jj))=sample(ii,ind(ii,jj))+1; 
end;end;
saveint(sample,'bootstrcounts.txt')

BS replications can be started from the true factor values 
(only for simulations), from random values,  from preceding 
no-pull factor values, or from best-fit factor values, see 
separate discussion.

In standard bootstrap, the non-sampled rows of XX (and AAM)
(i.e. those rows that have the sampling count of zero) 
are declared to be missing values, thus they have no weight 
in the fit. In bootstrap replication tasks, normalization 
of A columns is based on the sampled rows, multiplied by 
their sampling counts. Thus there is sampling variation
in A normalizations. This variation is also reflected
in B values if the A*B model is used.

Different versions of BS can be specified by using the 
variable bsmode.
The default setting bsmode=11 corresponds to "standard" BS,
as already explained. For other settings, see definition
of variable "bsmode", in the script proper.

Results of repetitions (for all free factor matrices, i.e. 
                        A, B, and C, also for PF and CM in the extended model) 
are pooled together in matrix RESLT. However, in the present
version, the results for matrix A are not output because 
results for A have not been verified yet.
Output file 51 contains information from table RESLT. 
The first columns contain special summary information, the
remaining columns contain results from each BS replication.
Each row corresponds to one element in matrix B, C, PF, or CM.
The file contains the following columns:
  - the true value (only for simulations, not for real data),
- the best-fit value
- smallest computed value,
- second smallest computed value,       
- ...                                     and so on until
- numextrem'th smallest computed value,
- numextrem'th largest computed value,  
- ...                                     and so on until
- largest computed value
Each of the remaining columns represents one BS replication.
The default value of numextrem is 6.


BS-DISP hybrid error analysis
-----------------------------
  As phase ß1, BS is run in the usual manner, without random 
pulling, with errestmode=2.
The following results are written in file BSDISP.txt:
  
  
  Phase ß2 is reserved for screening and sorting of BS results
and for other future tasks. Not implemented yet.
If factors are resorted in ß2, then also their child arrays
must be resorted!
  
  
  Phase ß3 is a modified DISP run. This run reads first the same
files as the original BS run, except that the errestmode code 
must be = -3.
Then a loop of resamples is entered. From the file BSDISP.txt,
definitions of resamples are input, one at a time. The first
analysis is the full-data best-fit case, however.
After that, specifications of BS resample best-fit results
are input. Each best fit is recalculated, just in case because
there might be minor adjustments in the iniparams values.
Operations are organized using taskxcount: it is reset to 1 
each time a new resample best fit is computed
For each resample, the following information is read:
  
  - control code: 
  1  for full data, 2 for good resample 
-1  for rejected resample (if factors have been swapped in a 
                           BS resample where factor identities are assumed known)
0  end marker

- number of defined free factors (including unused, if any)

- BSCOUNTS
- (BSWEIGHTS)
- All used free factor elements:  AA, BB, CC(, PF, CM)(, AERPENE)
- All relevant factor child arrays, because factors might
have been resorted in ß2

2010-10-30
Reference values used in resorting factors and in error analysis
----------------------------------------------------------------
  Depending on situation, the following alternatives are used
as reference factor values TRUEAA and TRUEBBCC. They are set only
in the following three places:
  - true values              in all simulation studies     (set in preproc)
if> ( simu==1 | (taskcount<1.5 & simu>1.5) ); 
##s=' simulated true factors';

- initial values spefified for first task         
- only in non-simu (BS-)DISP if bsinitfact==1         (set in preproc)
if> (simu==0 & taskcount<1.5 & bsinitfact==1 & errestmode<-1.5); 
TRUEBBCC[0,0]=BBCC[0,0];    % Fake TRUEBBCC is = initial values
TRUEAA[0,0]=AA[0,0];
##s=' Initial full-data factors';

- best-fit values, from first task, in non-simulation studies, 
in all other cases except for those listed above      (set in postproc)
if> ( simu==0 & taskcount<1.5 & (bsinitfact~=1 | errestmode>-1.5) );
##s=' Best-fit factors';



Differences between non-GUI and GUI use of script
-------------------------------------------------
  One control variable, defined at the head of the first
"variables" list, below, modifies the actions of script in this
respect. This definition should be edited by hand as needed.
For non-GUI runs use:        'gui'=0,
For running under GUI, use:  'gui'=1,

$endskip


$listing 0

section> defines;    %%%%% Beginning the first section "defines" %%%%%%

version=1.343;
monitor=20;          % originally =10
stabilizer=0.0;
robust=1;            % =1 for computing in the robust mode
posoutdist=4;  % these will be automatically loaded to XX.xxxoutdist
negoutdist=4;  % and AAM.xxxoutdist after section "defines"

missdatlim=-990;      % use -7.7E17 if neg data are not "missing"
bdlneg=0;                % =1 if neg values represent BDL

% Convergence tests and other parameters for the
% three iteration levels --- see below          
% Shortest and longest allowed CG sequence --- see below

precmode=20; numtasks=101; 
% Usually, numtasks is controlled by iniparams.
% Note that DISP and BS-DISP usually modify numtasks in order to
% end the run when all is done or when an error occurs.
% In other cases, the value set to numtasks will remain valid
% unless something special (surprise errors, say) happen.

% This script is always controlled by parameter file "iniparams.txt"
% Many of the preceding and following settings are overridden when
% file iniparams.txt is read. However, the value of variable "gui" 
% MUST BE MANUALLY UPDATED according to your needs, see below.
% -------------------------------------------------------------------
  
  % Activate (uncomment) following "define" line for extra debugging output
% In normal runs, comment the line out (start it with a % character)

%$define Xdebug


variables                 %
'iniparamv'=161110,       % previous were 150609, 180209, 231108, ... 
% Version stamp (=date) for the format of iniparams.txt file.
% stamp must be updated whenever a new incompatible format of
% iniparams is adopted. Stamp is included in file iniparams.txt
%%%%  'readinipar'=1,  % Obsolete. Current script is always used under
% control of file iniparams.txt, both under GUI and without GUI. 
% This action was originally specified by setting readinipar=1
'gui'=0,   % = 1: running under GUI
% = 0: run independently of the GUI
% =-1: run independently of the GUI, use special file naming

'modifcode'=0,  % Modification code 
% =0: standard, =1: for Palookaville data
% =2: compact DISP result information is written to file 42

'numoldsol'=1,  % The number of the desired starting-point solution in
% the solution file that was written by the previous run.
% (used in a continuation run when contrun==1)
%Next 5 rows Inserted by YS
'ntextcols' = 1, % number of text columns in table
'numidcol'=1,    % the (first) id column among these
'numid2col'=0,   % the second id column,  or =0 if no 2nd id column
'stdwithxx'=1,   % =1 if conc. columns are followed by std cols
% =0 if concentrations table does not contain std 
'bsinitfact'=0,
% For non-simu non-DISP non-BS, bsinitfact is not used at all.
%    --- for BS replications:
  % Specify initialization of factors. Codes are:
  % =  0  Default action: initialize from true values for simulation BS,
%                       from best-fit values for other BS
% =  1  Initialize from random values
% =  2  Initialize from best-fit values
% =  3  Initialize from true values      (only for simulations)
%    --- for dQ-controlled DISP and BS-DISP error estimation:
  % Specify if/how true-value information is available
% =  0  Default: true values are not available. Best-fit values are used
%       for reference and are written in the DISP output table.
% =  1  Initial factor values, as read from a file, are used for correlation
%       reference. These "true" BB values are written in DISP output.
% =  2  For simu=3 only: the generated true BB values are
%       written in DISP output table instead of the best values

'bsmode'=14,  % specify bootstrap mode.
%  The codes are as follows (n1 denotes # of rows in the matrix): 
                             % =  0  bsmode=0 should never be set by the user
                             %       The script overrides user setting of bsmode and 
                             %       sets bsmode=0 whenever no error estimation
                             %       by bootstrap is specified by errestmode
                             % = 11  The conventional bootstrap, where n1 rows are sampled with 
                             %       replacement and the non-sampled rows are truly omitted
                             %       so that their weights are == 0.0
                             % = 12  Was: modified conventional bootstrap (removed from script)
                             %
                             %       =13 was: Modified conventional BS, modified so that all 
                             %       rows have non-zero weights (=13 was removed from script)
                             %
                             % = 13  Obsolete!!!! bsmode=13 used to mean: "estimate errors by
  %       pulling or displacing each one of BB elements up and down
  %       Now error estimation mode is controlled by "errestmode"
  %
  % = 14  BS of residuals. Does not use weighting for BS. All rows are 
  %       included in the analysis and their weights are not changed.
  %        - for 50% of rows, data values are replaced by best-fit 
  %          fitted values (i.e. residuals are made to =0)
  %        - for the remaining 50%, residuals are doubled so that
  %          data values are replaced by   2*measured - best-fit
  %        - all normalization weights are = 1
  %       With this BS of residuals, the Q contribution from XX
  %       approximately doubles. This is normal. How are
  %       outlier limits handled????????????????????????????
  % = 15  Modified bootstrap, supposed to be statistically equivalent
  %    to conventional BS because the distribution of weights
  %    shares the properties (E(weight)=1.0, var(weight)=1.0) 
  %    of Poisson weight distribution. 
  %    Only two non-zero (non-integer) weights occur in weight
  %    distribution. Hence, all data rows are analyzed in each
  %    "resampling", hopefully leading to more stable replications.
  %    Weight distribution is controlled by two parameters wga and wgb.
  %    User specifies wga, script sets wgb=1/wga so that wgb*wga=1.0.
  %    The weights are 1-wga and 1+wgb, with probabilities wgb/(wga+wgb)
  %    and wga/(wga+wgb), respectively. With wga=0.5, the weights are
  %    0.5 and 3.0, with probabilities 0.8 and 0.2, respectively
  
'simu'=3, % simu=0 for analyzing real data, as read into matrix XX
          % simu=1 create true factors anew for each new task, and 
          %        simulate XX anew, using new factors & new noise
          % simu=2 create true factors once, 
          %        simulate XX anew for each task, using new noise
          %        for each task (no bootstrap or pulling, formulate
          %        a table of results)
          % simu=3   create true factors once, create XX once, run
          %          follow-up error estim. tasks with BS or DISP 
          % simu=3.1 read true factors once from end of iniparams, 
          %          create XX once, run follow-up error
          %          estimation tasks with BS or DISP 
          % simu=4   create true factors once, create XX once,
          %          run all starts from random values
          % simu=4.1 read true factors once from end of iniparams, 
          %          create XX once, run all starts from random values
             
             % The "start from" in this table can be overridden by
             % bsinitfact>0 values for BS replications
'contrun'=2, % contrun specifies how initial factor values are generated 
             %.. they are denoted by (*) in the following list:
   %         Earlier items in list have higher priority
   %
   % In 2nd task of any BS replication (i.e. with AA perturbations):
   %                    (*)=previously computed factors
   % contrun 
   % =0 & errestmode=0    (i.e. no BS, no DISP):
   %                (*)=random values, both for simu==0 and simu= 1,2,3,4
   % =1 &          task# >1 & BS pulling & bsinitfact=1:
   %                                      (*)=random values
   % =1 & simu=0 & task# =1:              (*)=factor values read from file
   % =1 & simu=0 & task# >1 & BS pulling: (*)=best-fit factors
   % =1 & simu=0 & task# >1 & (other repetition??): (*)=best-fit factors ??
   % =1 &          task# >1 & DISP (real data): 
   %          if level=1: (*)=best-fit factors
   %          if level>1: (*)=previously computed factors
   % =2 & simu>0:
   %       if simu=3 & task# >1 & BS pulling & bsinitfact=2:  
   %                      (*)=best-fit factors
   %       if simu=3 & task# >1 & DISP: 
   %          if first displacement:  (*)=best-fit factors
   %          if other displacements: (*)=previously computed factors
   %       otherwise:     (*)=true factors
   % =0,1,2 & simu=4: (*)=random values
   % --------- other combinations are not allowed ----------------
   % Run simulation BS with contrun=2, simu=3
   % Run simulation dQ-controlled error analysis DISP with contrun=2, simu=3 
   %   With DISP, setting bsinitfact=0,1,2 does not control factor
   %   initialization but items in output tables and output comparisons
   %   (See definition of bsinitfact, above)

   % Specify error estimation mode
'errestmode'=0,  %  errestmode is defined in iniparams.txt!
   % =2: estimate errors using BS, without random A pulling
   %     Writes a large result file that may be used in a follow-up DISP phase
   % =1: estimate errors using BS and alternatingly random A pulling      
   % =0: skip all error estimation operations related to BS, DISP, or BS-DISP
   % =-1: obsolete, not used or tested in this version:  
   %         estimate errors by pulling individual BB/CC elements 
   % =-2: estimate errors by displacing individual BB/CC elements 
   % =-3: perform DISP phase of BS-DISP hybrid method
   %     This method uses variable "bsphase" for DISP phase control,
   %     and BS weights from file BStoDISP.dat for controlling which
   %     mode of BS is used. However, "bsmode" is also needed for 
   %     controlling AAM weighting!
              
'dotable', % set automatically, depending on simu, contrun and errestmode:
   % =1 if a table of results is to be written, including
   %    summary columns indicating smallest and largest
   %    values of each factor elements (= CI's)  (not for dQ-controlled DISP)
   % =2 if the table will also include the true factor
   %    values, (for simu=2 and simu=3)          (not for dQ-controlled DISP)
   % =0 for all other cases, such as DISP and BSDISP
              
'pullc1'=1.0, % 2.0 might be a weak BS perturbation pull, certainly not 
              % causing harm. Used as C1 for A factor pulling equations.

'readbscnts'=0, % =1: script reads BS counts from file prepared by GUI
                % =0: script generates BS counts as (Poisson or other) random 
                %     numbers (using seed5), then normalizes them to sum=n1.
'samplevari'=1, 
  % =0: there is "no population"  (or "sample == population")
  %     so that there is no sampling variation related to
  %     rows of matrix XX. Option 0 is only possible if all
  %     rows are included in BS resamples!
  % =1: rows of matrix XX consist of a random sample from a
  %     "large" population --> sampling variation in BS  
  % =2: sampling variation is not considered in BS. ANORMWG are adjusted
  %     according to each resample so that A and B remain invariant of the
  %     actual resample
  
'numbstasks',   % for BS-DISP, errestmode=-3: number of tasks in the preceding
                % BS run. Input from file BStoDISP.dat.

'wga'=0.5,     % If bsmode==15, the distribution of BS weights is 
'wgb',         %.. controlled by wga and wgb. Typically, wga=0.5. (See 
               %.. comment at definition of bsmode)

'maxtopull'=10.0,  % Upper limit for A factor elements to be pulled u/d 
'mintopulld'=0.05, % Lower limit for A element to be pulled down. Limit is
                   % relative to max element on that row of A.
'pulldist'=3,      % Distance of pulling anchors from the original A values
                   % subject to random rotational pulling in BS
                   
'alowlim'=-0.2,  % Lower limit for computed A factors, should be slightly 
                 % negative 
               
   % for generating "true factors" in simulation
   % see SIMUTABLE
     
'numextrem'=6,  % The script analyzes confidences corresponding to
                % numextrem smallest and numextrem largest BS-computed
                % values of each factor element
'acbmodel'=1,   % =0: use A*B model   
                % =1: use A*C*B model, normalize B to bnorm
'bnorm'=0, % Mainly in A*C*B models: sums of B columns are normalized
           %   to be = bnorm. 
           % if original bnorm=0, script will later automatically set
           %   bnorm=1 or bnorm=n2, depending on the value of simu.
           % if original bnorm>0, its value will be used as such
'fullprec'=1, % if =1 and A*C*B: whole matrix BB plus CC form one large
              %     preconditioning block. Good convergence but may be
              %     (very) slow if the product n2*np is exceptionally large
              % otherwise: standard precond, each row of BB is one block
'seed1','seed2','seed3','seed4','seed5',

'numpf',     % Number of ordinary parametric factors
'numynpf',   % Number of yes/no parametric factors 
             % Set  numpf=0;   if the customary 2-way model is  
             % to be fitted but not the parametric model. 
'numpfind',  % Number of indices pointing to parametric factors for
             % each sample. Usually,  numpfind=numpf+numynpf
'maxpfdim',   % Largest number of classes for any parametric factor
'rewgxxm'=1,  % The parametric AAM equations are reweighted (i.e. resampled) 
              % in BS replications if rewgxxm==1 and bsmode==11 or ==15
'modelc1'=1.2,   %  AAM C1 value           
'modelc3'=0.35,  %  AAM C3 value for all AAM equations, note em =-5
'modelem'=-5,    %  em code for AAM equations
'cmlowlim'=0.0,  % low limit for CM factors
'pfpullc1'=1.1,  % C1 for pulling-to-1 equations of PF factors
'pfsmooc1'=0.5,  % C1 for smoothing equations of PF factors
'pfnormc1'=1.0,  % C1 for normalizing equations of PF factors

'doresort'=1,    % should be =0 or -1 in dQ-controlled error estimation runs
  % In dQ-controlled error estimation (errestmode<0), the value doresort=1
  %     is automatically overridden if errestmode=-2 has been set.
  %  1: allow re-sorting of computed factors (not in the first task)
  %     so that the ordering matches the order of factors in task 1
  %     In BS, allow re-sorting only with bsphase=1, i.e. for the first
  %     (non-pulled) task of each BS replication.
  % -1: compute the correlations with first task but do not allow re-sorting
  %  0: do not allow re-sorting, do not compute correlations. 
  % Re-sorting is usually harmful if factor-specific a-priori info
  %     is applied, such as forcing or constraining individual factors or
  %     using individual FPEAK values for different factors
  
'rowtypecol'=0,  % position of the extra column in matrix XX. 
    % The extra column is intended for reading row type codes 
    % (alternatively, row type codes, if needed, might be read by 
    % commands inserted in this script manually by the user).
    % If row type codes are not needed, the extra column may still be 
    % present in XX: -- it must be read if it is present. 
    % If rowtypecol=0, no extra column is present in matrix XX. 
    % If rowtypecol=kk<=n2, extra column is before column number kk of 
    % the original XX. If rowtypecol=kk>n2, the extra column is at
    % far right, after the last column of XX. 
    % Recommended:  rowtypecol=0,  =1, or =999.
'numrowtyps'=1,  % number of row types. =1 if row typing is not used.
    % If =1, ROWCODES[j1]>1 are ignored, they are reset to be =1.
    % If numrowtyps>1, the matrix FACTORUSE is read by subroutine 
    % "Prepare" from the end of file iniparams.txt, 
    % after "dofpeak" but before fpeak or FPEAK value(s).

'aeruse'=0,     % =1: AER modeling is used, requires numrowtypes ==3
'numaerc'=10,   % max. number of AER classes
'aerC1'=0.2,    % C1,C3 specify uncertainty = 30% + 0.2 in A factor
'aerC3'=0.3,    %.. elements of indoor+personal samples in AER model equations
      
'fpeak'=0,     % Input by subr "prepare" if dofpeak==1      
'dofpeak'=0,   % Control of rotations (cf. Fpeak in PMF2).
  % =0: No Fpeak-like rotations
  % =1: Read a single value fpeak, store it into all elements of 
  %     matrix FPEAK, and perform rotations similar to PMF2.
  % =2: Read all elements of FPEAK matrix. Perform individual rotations 
  %     that are a generalization of PMF2 rotations.
  % Elements in matrix FPEAK correspond to Fpeak of PMF2:
  % >0 means that AA (=G) factors are added to each other, causing
  %    contribution profiles (time series) to contain fewer non-zero 
  %    elements
  % <0 is the opposite: AA factors are subtracted from each other,
  %    often causing G edges to become aligned with coordinate axes
  % =0: no rotational effect
  % FPEAK[qq,pp] controls the strength of addition/subtraction of
  %              A factor qq to/from A factor pp.
  % Different elements of FPEAK can be of different magnitudes and
  % even of different sign (+ and -).
  % Elements  FPEAK[ii,ii] have no significance but they must be 
  % present in the matrix that is read.

'dispstcode',  % DISP step success code:
   % =1: accepted step
   % =2: high-Q step
   % =3: rejected step, 2 or more factor swaps
   % this code not used after 2010-10-09:  =4: rejected step, bad gradient
   % =5: DISP & BS-DISP:  displacement descends to a local minimum, deeper 
   %     than -10.0-DISPDQMAX[dispdqlevs] below (resample) best-fit Q
   %     
   
'dispstate'=-3,
% state codes (different from step classes)
% -----------------------------------------
% -3  no factors have been selected yet for up displacement
% -2  no factors have been selected yet for up displacement,
% -1  non-initial selection failed, i.e. all factors have been processed
%  0  factor selected for displacement
%  1  one or more accepted displacements, no bad or High-Q seen
%  2  high-Q-step has been seen
%  3  swap has been seen   (not any more: or bad gradient)
%  4  last step is ready for this factor, select next factor
%     storage of results occur if dispstate==4 "naturally", without errors
%     Some errors also lead to dispstate==4, but without storing the results
%  5  convergence with high-Q (success)
%     --------------------------- indicators, used also for DISP output?
%  6  convergence with rejected steps (failure)
%  7  max # of displacement steps exceeded (failure)
%  8  Q drops more than by -10-DISPDQMAX[dispdqlevs] (failure)
 
% pure DISP state diagram  (state code in script = "dispstate")
% -------------------------------------------------------- 
% states  -->  new state  on step code   (because of other reason)
%  0, 1           1           1
%  2              2           1
%  2              5           1      (convergence after High-Q)
%  3              3           1
%  3              6           1      (convergence: failure)
%  0, 1, 2, 3     2           2 
%  1, 2, 3        5           2      (convergence after High-Q)
%  0, 1, 2, 3     3         3,4 
%  1, 2, 3        6         3,4      (convergence: failure)
%  
%  1              4           1    (dQ>dQmax(4), last step ready
%                                   .. or an outdisp step)
%  5              4
%  6              4                                 
%  4              0             (next factor selection OK)
%  4             -1             (next selection failed..)
% -1             -2             (.. it was up selection, --> down)
% -1             -1             (.. it was down selection, --> end DISP)
% -3,-2           0             (first factor selected OK by Dispnext)
% -3             -3             (first up selection failed, --> end with error msg) 
% -2             -2             (first down selection failed, --> end DISP) 

   
'dispj2'=1,   % Counters for keeping track of error estimation:
'dispjp'=1,   % indices j2 and jp and 
'dispup',     % indicator of up/down direction, = +1/-1, respectively
'dispud',     % number of row, e.g. in DISPLTABLE for displacement coeffs
              % =1 for down, =2 for up displacements
'dispind',    % index of current perturbation, i.e.
              %.. of displacement level   (if errestmode=-2)
'dispdq1',    % value of dQmax at any moment               
          % All the indices, above, are (re)set in postproc of the preceding task.
'dispbsnumb'=1,  % BS-DISP: number of full-data or resample just read from file BStoDISP
                 % =1 in DISP and other cases where not used
                 % Internally, =1 indicates best fit. 
                 % In output, =0 is best fit, >0 is true number of resample just read
'dispbsOKn'=0, % Number of accepted resamples processed in BS-DISP, to be written to 
               % output files (including full-data case)
               
'disprejsco'=0,    % reject score for DISP and BSDISP: 
   % 0:  no problems
   % 2:  swaps in BSDISP resamples (best fit or DISPed)
   % 4:  Q decreases in BSDISP resamples (best fit or DISPed)
   % 6:  swaps when DISPing full data (DISP or BSDISP)            
   % 9:  Q decreases when DISPing full data (DISP or BSDISP)            
'disprejthr',    % user-defined reject threshold for DISP and BSDISP
   % reject if score >= threshold
   % disprejthr also controls when reject occurs after swaps:
   %  disprejthr<2: abort processing of resample immediately when swap seen
   %  disprejthr=2: after swap, continue processing of resample, but reject
   %                results after computing all displacements
   
'dispswap1'=0.9, % Limits for detecting swaps: if diag/colmax<dispswap1 ==> swap
'dispswap2'=0.5, %...  if diag<dispswap2 ==> swap 
'dispdqlevs'=4,  % Number of dQ levels, used mainly for DISP but also 
                 %.. for BS output. Must be <7.
'dispmxnum'=20,  % Max # of displacements
'dispokmx',    % last (=longest) accepted displacement for this factor element
'dispbadmin',  % last (=shortest) rejected or "bad" displacement
               % =0 if no bad displacement has been detected for this factor elem.
               % dispokmx moves towards longer moves, badisp towards shorter ones
               % both are initially =0
'dispstepxx'=0.25,  % step increase fraction (constant), originally = 0.20
'dispstep',        % current step length (>0 or <0) i.e. increase of displacement
'dispnow',        % current (contemplated) displacement, >0 (up) or <0 (down)
'dispmindis',   % tolerance for this factor element. Set in Dispnext.
'dispstpcnt',   % counts all steps (accepted and rejected) for this factor element. 
                % Used for preventing premature false convergence
'dispdQok',     % cumulative change of Q from the best-fit Q to the Q of the last
                % accepted displacement "dispokmx". Stored in table DISPLTABLE
'dispHQdone',   % High Q step was done for this factor element
'dispdQneg'=0,  % Is <0 if Q has decreased below its original best-Q value:
                % indicates then the largest drop of Q seen in the run

'dispFscale'=1,   % Column sum for scaled F min/max estimates, typically =1 or =100
'degfreedom'=0.5, % coefficient for compensating for variations between 
                  % free vs. constrained parameters. Input after DISPLTABLE.
'dispgracut'=0,  % OPTIMIZATION: if dispgracut>0, if also
                 %.. abs(grad of displaced factor) < dispgracut, and this has 
'dispgracnt';    %.. occurred in 5 contiguous callback executions, 
                 %.. callback terminates the task.             
                 % This causes end code =3 instead of the usual =4. !!!???
           % Must not terminate with first occurrence because reorganization of 
           % factors might sweep the gradient value through zero (???)
           % N.B. dispgracut=0 in all non-DISP runs and in task 1 of DISP runs.
                 

% Default specifications for constructing certain file names
% ----------------------------------------------------------
                % input files
##d='pmfdata.txt';      % The main data file
##p='PMF_prev_res.dat'; % The results of a previous run
                % output (result) files
##m='PMFres';       % Main part of title for several files
##b='PMF_BS.dat';   % Table of results from BS replications
  % ##b will be reset to 'DISPest.dat' if DISP perturbation is selected
##r='PMFreport.txt';    % Info for GUI: Q values etc.


sd=26; se=26;

% Temporary construction for file names, used for massive
% systematic simulation runs. Enabled for testing by setting gui==-1
% May be removed from EPA PMF distribution version
% *** Does not work if iniparams.txt is used *** ???
% -------------------------------------------------------------------
if> (gui==-1);      % File naming enabled by gui==-1
  ee=0;             % Loop for computing with different seeds:
  while> (ee==0);   % Do as long as ee==0  indicates that the file 
                    % in the openfile command was present
    sd=sd+1; se=se+1;            % what about this seed?
    ##m='res53s',sd,'(I2)';   % construct file names for this seed
         % Main part of names of files to be written
    ##b='BS53s',sd,'(I2)','.dat';        
         % File name for table of results from bootstrap replications
    ##2=##m,'.txt';            % check if main output file is present
    openfile 40, ##2, R, 'old', 2000, ee;     % and close it if found
    closefile 40;
  while!;           % exit while loop if file is not present
if!;
% -------------------------------------------------------------------

% Specification of pseudorandom seeds, to be used for ..
seed1=sd;     % .. generating initial "random" factor values
seed2=sd;     % .. simulating noise that is added to simulated X
seed3=se;     % .. generating "true" factor values for simulations 
seed4=sd;     % .. picking the factors to be pulled
seed5=sd;     % .. generating pseudorandom BS sampling counts


% Specifications related to user-specified pulling aux equations 
variables 
'usemorepar'=0,   % obtains value >0 if file moreparams.txt is present
                  % and (numGpull+numFpull+readGcontr+readFcontr) > 0
'numGpull'=0,     % number of equations pulling AA elements
'numFpull'=0,     % number of equations pulling BB elements
'readGcontr'=0,   % if =1, read AA.fkey, AA.flow, AA.fhigh
'readFcontr'=0,   % if =1, read BB.fkey, BB.flow, BB.fhigh
'numpulcons'=100; % minimum size of constant factors vector, used for
                  % storing weights for weighted sums in eq's


variables     % For internal use by the script. Do not initialize! 
% -----------------------------------------------------------------
'file14ok',     % =1: file 14 has been successfully opened
'numfreef',     % number of free factor elements, including CC
'numabfact',    % total number of AA and BB free factors only
'numconsfac', % number of lowlim-constrained best factors
'bsphase'=0,  
    %===== in BS runs: phase of bootstrap (0--> 1--> 2--> 1--> 2..):
    % <=0: there is no resampling, no pulling in this task (or in this run)
    % 1: this is the first of the two tasks of BS replication, there 
    %    is resampling but no AA pulling in this task
    % 2: this is the 2nd task of BS replication, previous resampling 
    %    is retained. Set up AA pulling, start from previous result.
    %    bsphase=2 not used in BS that prepares for BS-DISP
    %===== in pure DISP runs (errestmode=-2) and when errestmode=0,
    %          bsphase=0
    %===== in DISP runs of BS-DISP, bsphase indicates phases of outer loop
    %  0: analysis of full-data best-fit case (taskcount=1)
    % -1: initiate for analysis of next case (first resample or next resample), 
    %     perform best fit of that case (in order to obey minor variations 
    %     of the run with reference to the original BS resample best run)
    % -2: perform perturbations of individual factor elements
    % -3: output results from full-data or resample (unless disprejsco prevents output)
    % -4: no output, reject this resample at once because of a DISPing swap
    % -5: after last resample, output final results, end the run
    % -6: no output, reject this resample because of local minimum
    
'splitBSres'=1, % =1  =number of BS result tables !!!!!!!!!!!!!!!!!!!!!!!
    % The intended option splitBSres=2 is not correctly programmed and 
    % cannot be used in this version.
    % modify this initialization only if you know what you are doing!
    % 2: unpulled and pulled tasks are summarized and output in 
    %    two different independent result tables
    % 1: default (original setting), all tasks are pooled together
    % If not BS, or if BS of BS-DISP, splitBSres will be reset to 1 soon.
'sortAcorr'=1,  % if =1, uses A correlations instead of B correlations
                % in order to re-sort solutions to same ordering as base case    
'splitBScod'=1, % =1 or =2,  code of BS table used at the moment    
'numpull',    % # of A elements pulled up, and also of those pulled down  
'numhp',      % # of the elements selected to be pulled down/up
'readtruef'=0,   % =1 if simu was = 4.1 or 3.1, indicating that true factors
                 % are input from iniparams.txt, factor vectors in columns
                 % =2 if simu was = 4.2 or 3.2, same as above except that
                 % factors are on rows of input matrices (transposed format)
'outdisp'=0,  % =1 if the current displacement is the longest possible,
              % either down to .flow or (typically for normalized BB) up  
              % to up-constrained .fhigh (used only for errestmode==-2)
'di1',        % for DISP, =dispind+1
'usedpullwg'=0,  % counter for constant weights in vector GFPULCONS
'qxx',        % Q(XX)
'bestmainq',  % The mainqvalue from task #1 in DISP estimation
              % and possibly in other use, too
'smalldiag',  % # of non-dominant diagonal terms in matrix T1 of (G1=G0*T1+R)              
'colavgsum',  % sum of column averages, approx. = average of row sums
    % Approximately:
    % In A*B model:     sum of BB[j2,0] is = COLUMNAVG[j2]
    % In A*C*B model:   sum of C elements is = colavgsum / bnorm
    
'deltaq',     % increase of Q in one DISP step (one change of displacement)
'deltagrad',  % computed change of gradient component in one DISP step
'deltaQmax'=0,      % largest and smallest deltaQmain, as caused by pulling 
'deltaQmin'=10000,  %.. in BS replications
'nonpullQ',         % Qmain when bsphase=1
'didsort',    % Indicates re-sorting of factors:
              % =0: resorting not enabled  =1: resorting was enabled and performed
              % =-1: resorting was enabled but not performed, not needed
'stopped'=0,  % indicator for stopping ME-2 by the file pmfstop.txt
'taskxcount'=1,  % Used for controlling script operations, such as 
                 % initialization of matrices. Is = taskcount except for
                 % DISP part of BS-DISP. Incremented at top of preproc.
'statuscnt',  % Counter for controlling when status file should be written
'stopcnt';    % Counter for controlling when stop file should be read

%----------------------------------------------------------------- 
% Set dimensions of the model:
%   dim. of mode1    mode2      number of factors
            n1=100;    n2=12;         np=5;
%            
% Numbers of:  param.factors   y/n param.f.         
                 numpf=3;       numynpf=1;  
% (numpf=0  indicates that parametric model is not fitted at all)
%----------------------------------------------------------------- 
%  std-dev coefficients and errormodel code for the main equations
     c1=0.35;  c3=0.10;        em=-12;
% If c1==0, the script reads C1 values from file 30.
% If c1>0, c1 is used as C1 value for all data values.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%                                                                 % 
%  All control variables that are intended for user modification  % 
%  are set before this point. Any modifications of them should    % 
%  be performed above, not below this point.                      % 
%  Exception: modifications of output formats can only be         % 
%  performed below, in section postproc.                          % 
%                                                                 % 
%  Experienced users might also modify the code below this point. % 
%  If you perform such modifications, please also update the      % 
%  modification history, at the top of the script, and comment    % 
%  carefully your modifications!                                  % 
%                                                                 % 
%  When running under the EPA PMF licence, then the section       % 
%  "equations" cannot be modified.                                % 
%                                                                 % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

$listing -1

% Override many control variables specified so far by reading the values
% from file 14, "iniparams.txt",  prepared by the GUI or by the user.

ee=1;         % ee=1:  iniparams.txt not yet opened 
              % ee==0: iniparams.txt successfully opened
file14ok=0;

if> (ee~=0);   % Try to open file 14. If it succeeds at once,
               % there is no need to check "stop" and "kill" files.
  openfile 14, 'iniparams.txt', R, 'old', 500, ee;
  if> (ee~=0); write 6, '(/1X,A,/)', 
    'File iniparams.txt not present. Waiting for the file to appear.';
  else;     file14ok=1;   %  Ready to read file 14
  if!;  
if!;

% Waiting loop, needed for interaction with the GUI. 
% If the file iniparams.txt is to be read but the file is missing,
% the script will wait here indefinitely. If this happens, use
% control-C in command window to end the run!
% ------------------------------------------------------------------
while> (ee~=0);  
   % Wait until the file iniparams.txt is present. At the same time,
   % obey the stop and kill commands that might be issued by the GUI.
  openfile 14, 'iniparams.txt', R, 'old', 500, ee;
  openfile 16, 'pmfstop.txt',   R, 'old', 200, e1;
  openfile 18, 'pmfkill.txt',   R, 'old', 200, e2;
  if> (e2==0);          % Kill request file is present. Do not delete it.
    closefile 18;
    openfile 15, 'pmfstatus.txt', W, 'replace', 200, e0;
    if> (e0==0);        % Status file was opened successfully. Update it. 
      write 15, '(1X,A)', 'PMFkilled         0         0         0';
      closefile 15;     % Close status file.
    if!;
    stop 'Kill command detected';    % Stop because of the kill command. 
  if!;
  if> (e1==0);          % Stop file is present. Delete it.
    closefile 16, delete;
    openfile 15, 'pmfstatus.txt', W, 'replace', 200, e0;
    if> (e0==0);        % Status file was opened successfully. Update it. 
      write 15, '(1X,A)', 'PMFstop#2         0         0         0';
      closefile 15;     % Close status file.
    if!;
    stop 'Stop command detected while idling';
  if!;
  if> (ee~=0); sleep 3;   % No iniparams file. Wait and try again later.
  else;     file14ok=1;   %  Exit from while loop and read file 14
  if!;
while!;
% ------------------------------------------------------------------

if> (file14ok);    % Read file iniparams.txt, except for values of 
                   % FACTORUSE, fpeak, FPEAK, and End Marker
  read 14, ' ', iv; 
  if> (iv ~= iniparamv);
    stop 'Your iniparams.txt is not compatible with this script';
  if!;
  
  
 $skiplines 
  read 14, ' ', modifcode;
  read 14, ' ', robust, posoutdist, negoutdist, precmode, numtasks, numoldsol;
  read 14, ' ', bsinitfact, bsmode, simu;
  read 14, ' ', contrun, errestmode, disprejthr, pullc1, readbscnts, samplevari; 
  read 14, ' ', alowlim, acbmodel;
  read 14, ' ', seed1, seed2, seed3, seed4, seed5;
  read 14, ' ', n1,   n2,   np,   c1,   c3,    em;
  read 14, ' ', numpf, numynpf, maxpfdim, modelc1, modelc3, pfpullc1, pfsmooc1;
  read 14, ' ', ##d, ##e, ##p; 
  read 14, ' ', ##m; 
  read 14, ' ', rowtypecol, numrowtyps, aeruse, doresort, dofpeak;
  $endskip
  
  %$skiplines
  read 14, ' ', 
  modifcode,
  robust, posoutdist, negoutdist, precmode, numtasks, numoldsol, 
  bsinitfact, bsmode, simu, 
  contrun, errestmode, disprejthr, pullc1, readbscnts, samplevari, 
  alowlim, acbmodel,
  seed1, seed2, seed3, seed4, seed5,
  n1,   n2,   np,   c1,   c3,    em,
  numpf, numynpf, maxpfdim, modelc1, modelc3, pfpullc1, pfsmooc1,
  ##d, ##p, ##m,
  rowtypecol, numrowtyps, aeruse, doresort, dofpeak;
  %$endskip  
if!;
if> (simu==4.1 | simu==3.1);    readtruef=1; simu=simu-0.1;
elseif (simu==4.2 | simu==3.2); readtruef=2; simu=simu-0.2;
if!;     % True factors are to input, not read

% In subroutine "prepare",  FACTORUSE(matrix), fpeak(scalar),
% and/or FPEAK(matrix) (in this order) are read from file 14 
% but only in cases when they are needed:
%  - read matrix FACTORUSE if numrowtyps>1
%  - read scalar fpeak if dofpeak==1
%  - read matrix FPEAK if dofpeak==2


% Try to open & read file moreparams.txt (only if contrun)
% --------------------------------------------------------
if> (contrun>0.5);
  openfile 13, 'moreparams.txt', R, 'old', 20000, ee;
  if> (ee==0);  % Read dimensions if file 'moreparams.txt' is present
    read 13, ' ', numGpull, numFpull, readGcontr, readFcontr, nu;
    numpulcons=numpulcons+nu;
    usemorepar=numGpull+numFpull+readGcontr+readFcontr;
  if!;  % Leave file 13 open for reading in next sections
if!;


% Normalization of B columns in the A*C*B model - change if needed 
% ---------------------------------------------------------------- 
if> (bnorm <=0);     % 0:  change bnorm to its default value
  if> (simu>0 );   bnorm=n2;      % B column average =1
  else;            bnorm=1;       % B column sum =1
  if!;    % These settings are mainly relevant for the A*C*B model
if!;      %.. but they are performed also in the A*B model.
          %.. They are used for recovery from some abnormal situations
% ----------------------------------------------------------------

% Coming here when file 14 (iniparams.txt) has been detected and read. 
% If non-GUI, file 14 will be closed when the script ends. 
% If GUI:
% File 14 will be closed-deleted when the script ends
% If file 14 still exists when the ME-2 GUI run has finished, 
% it means that the run has been ended in error.

% Internal settings. Do not change.
% ----------------------------------
numfreef=n1*np+n2*np+np;   % AA & BB & CC (in this order) 
                  % CC is present in both A*B and A*C*B models
if> (numpf>0);   % Account for   PF   and     CM
  numfreef = numfreef + maxpfdim*np*(numpf+1)+np;
if!;
if> (aeruse==1);
  if> (numrowtyps ~= 3);
   stop  'In this version, aeruse=1 requires numrowtyps=3';
  if!;
  numfreef = numfreef + 2*numaerc*np;    % Account for AER infiltration factors
if!;
if> (dispdqlevs>6); stop 'dispdqlevs must be < 7';
if!;

 numabfact=n1*np+n2*np;
 numpull=Minval{np*np, Roundtozer{0.08*n1}};    % At most 16 %
            % .. of all rows can be pulled (up and down taken together)
 if> (contrun==2); 
   if> (simu==0);     stop 'With contrun =2, simu must be >0';
   if!;
   goodstart=1;    % starting from true factors, i.e. from good values
 elseif (contrun==1);
   if> (simu>0);      stop 'With contrun =1, simu must be zero';
   if!;
   goodstart=1; 
 elseif (contrun==0);
   if> (errestmode~=0); stop 'With contrun =0, errestmode must be zero';
   if!;
 else;                stop 'Undefined value of contrun';
 if!;
% if> (usemorepar>0.5);   % Factor-specific info is present. No random starts.
%   if> (contrun==0 | (bsmode>0.5 & bsinitfact==1) | simu>3.5);
%     stop 'Using file moreparams.txt prevents use of random starts';
%   if!;
% if!;  
 if> (usemorepar>0.5);   %  Factor-specific info used. No random starts.
   if> (contrun==0 | (errestmode>0.5 & bsinitfact==1) | simu>3.5);
     stop 'Using file moreparams.txt prevents use of random starts';
   if!;
 if!;  
 if>(simu==4); goodstart=0; 
 if!;
 
 if>    (simu==3 & numtasks>1 & errestmode>0.5);  
          % Simulations, true is known, many true/random starts, doing BS 
       dotable=2; 
 elseif (simu==2 & numtasks>1 & errestmode==0);  
          % Simulations, true is known, many starts with different noise
       dotable=2;
 elseif (simu==0 & contrun==1 & numtasks>1 & errestmode>0.5);  
          % Many best-fit starts (real data), doing BS & pulling
       dotable=1;   
 else; dotable=0;   % Real data with random starts, or one single
 if!;             %.. task, or simulations (no BS) with varying factors,
                  %.. or simulations (no BS) from random starting points
                  %.. or DISP or BS-DISP estimations
                  
 if> (bsmode < 10.5 | bsmode > 15.5);
   stop 'Bad value of bsmode';
 if!;
 
 if> (errestmode<0.5);   % Not a BS run
   if> (errestmode>-2.5);    bsmode=0;      % DISP:  bsmode not needed
   if!;
   splitBSres=1;         % prevent the command for double BS/DISP output
 elseif (errestmode>1.5);   % It is BS part of BS-DISP
   splitBSres=1;            % No pulled analyses, hence also no split results
 if!; 
 
 if> (bsmode == 11            % BS with samples truly omitted?
      & samplevari < 0.5);    % Equal-weights A normalization?
   stop 'Equal-weights A norm impossible with true resampling';
 if!;
 if> (bsmode == 15 & errestmode>0.5);   % It is a BS run
   if> (wga<0.1 | wga>0.9); stop 'Bad value of wga when bsmode=15';
   if!;
   wgb=1.0/wga;
 if!;
 numpfind=numpf+numynpf;
 

 if> (simu>0);          % Specify very tight tolerances for    
   Sysparam{4,0.0008};  %.. such normalizations that use errmod=-23
   Sysparam{5,0.0006};
   Sysparam{6,0.0004};
   if> (numpf>0.5); 
     stop 'This script does not simulate parametric factors';
   if!; 
 elseif (goodstart>0);   % Specify tight tolerances for normalization
   Sysparam{4,0.0010};   % N.B. when fine tuning normalization, use
   Sysparam{5,0.0007};   %.. the command "$define Xdebug", see above,
   Sysparam{6,0.0005};   %.. in order to get detailed diagnostic output
 if!;
% ----------------------------------------------------------
 
 
if> (errestmode<-1.5);  % Fixed displacements of factor elements
  if> (gui>-0.5);
     ##b='DISPest.dat';   % Table of results from DISP estimation
  if!;
  Sysparam{13,1};     % requests more CG restarts 
  convtests 
    0.0050,       30,       500,        0,      0,    0.00010,   % was 0.00005
    0.0030,       40,      1000,        0,      0,    0.00003,   % was 0.00002
    0.0005,       50,      2000,        0,      0,    0.00001; 
  % deltaQ   consecut.   max cumul.     not     not   gg2 norm
  %   test      steps    step count    used    used     test
  cgresets  8,  50,  1,  1,  1,  1;
  
elseif (goodstart>0);     % For continuation runs where reasonably good
                         % fit is present right from the beginning
  convtests
    0.0100,       30,       800,        0,      0,    0.0001,  
    0.0050,       50,      2000,        0,      0,    0.00005,  
    0.0003,      100,      5000,        0,      0,    0.000005; 
  cgresets  10,  90,  1,  1,  1,  1;

else;  % The standard version, for random starts 
  % Convergence tests and other parameters for the three
  % iteration levels.               %---Reserved --
  convtests                         %--for future--
    0.1000,       20,       800,        0,      0,    0.001,    %level 1
    0.0050,       50,      2000,        0,      0,    0.00005,   %level 2
    0.0003,      100,      5000,        0,      0,    0.000005;  %level 3
  % deltaQ   consecut.   max cumul.     not     not   gg2 norm
  %   test      steps    step count    used    used     test

  % Shortest and longest allowed CG sequence (basic length),
  % and four coefficients that modify the basic length.
  cgresets  10,  90,  1,  1,  1,  1;
if!;
 
% Definitions of all arrays, both numerical and text. Insert more
% definitions if needed e.g. for output operations.
% In a sealed script, additional _factor_ matrices cannot be defined.
% ----------------------------------------------------------------------- 
 %Next 8 rows inserted by YS
 defarr scripttext,  TEXTCOLS[n1,ntextcols];  % text columns in data table 
 defarr scripttext,  SAMPLEHEAD[n1];    % Header texts for rows of XX
 defarr scripttext,  AAHEAD[n1];        % Header texts for rows of AA
 defarr scripttext,  BBHEAD[n2];        %.. and of BB
 defarr scripttext,  BUHEAD[n2];        % Header texts for BB uncertainty rows
 defarr scripttext,  FACTHEAD[np];  
    % Insert descriptive names of factors in FACTHEAD (if known)
    % (Usually requires good initial values and contrun=1)
	
 defarr maindata, XX[n1,n2];  
 defarr scriptdata, ROWCODES[n1]; 
     % Optional user-specified row type codes that may be used for
     % various purposes. Initially, used in the EPA I/E 
     % (internal/external) model for factor usage information. 
     % By default, all ROWCODES[0]=1.
     % If numrowtyps=1, all ROWCODES[j1]>1 are reset to be ==1.
     % If numrowtyps=nr>1, ROWCODES[j1]>nr are illegal
     % ROWCODES[j1]=0  indicates that row j1 is not used at all ???
 defarr scriptdata, ROWDOWNWG[n1]; 
     % Row downweighting coefficients, used for improved start-up
     % if factor selection is used, i.e. if numrowtyps>1,
     % but only if contrun==0!
 defarr scriptdata, SAMPLEOK[n1];  
     % Row-specific codes generated automatically by the script
     % =0 for samples where parametric model cannot be defined,
     %    and for all samples if numpf=0, i.e. if no parametric model 
     %    is fitted
     % =1 for samples where parametric model can be defined
     % Definition can be extended for other purposes
     
 if> (numpf>0);  defarr maindata, AAM[n1,np];  
 if!;
 
 if> (numGpull>0);                    % Aux data for user-defined
   defarr auxdata, GPULLS[numGpull];  %.. AA pulling equations
 if!;
 if> (numFpull>0);                    %.. and for BB pulling equations
   defarr auxdata, FPULLS[numFpull];
 if!;                                     % Constant factors for
 defarr constfact, GFPULCONS[numpulcons]; %.. pulled expressions
   % Constants for all pulled expressions are stored here one by one,
   % even if several constants have the same numerical value
 
 defarr auxdata, NORMS[2,np];   % Aux data array for normalization
                                % equations for AA and BB factors
 defarr auxdata, APULL[n1*np];  % For random rotational pulling of A in original BS

 if> (dofpeak>0.01);   
   defarr auxdata, FPEAKPULL[n1,np];  % For FPEAK rotational pulling of A 
 if!;
 
 defarr scriptdata, BSCOUNTS[n1];  
   % bsmode=11: Indicates how many times each row is sampled 
   % bsmode=14: =0 for zeroed residuals, =2 for doubled residuals 
 defarr scriptdata, BSWEIGHTS[n1,2];
   % Column 1: 
   %  Weight of each row in a BS replication
   %  By default, BSWEIGHTS[0,1]=BSCOUNTS[0]  
   %  In all cases, sum of BSWEIGHTS[0,1] is = n1. 
   %  bsmode=14:  BSWEIGHTS[0,1]=1.0
   % Column 2: row weights for computing A correlations and regressions
   %  BSWEIGHTS[ii,2]=1 if BSWEIGHTS[ii,1>0]
   %  BSWEIGHTS[ii,2]=0 if BSWEIGHTS[ii,1]==0
% defarr scriptdata, BSNORMADJ[2,np];
%   % row 1: adjustment coefficients for normalizing A columns in BS resamples
%   % row 2: column sums of full-data best-fit AA (needed for computing row 1)

 if> (errestmode>1.5);    % BS phase of BS-DISP
   defarr scriptdata, BSNORMADJ[numtasks+2,np];
 else;
   defarr scriptdata, BSNORMADJ[2,np];
 if!;
   % row 1: column sums of full-data best-fit AA (for computing follow-on rows)
   % row 2: adjustment coefficients (for the current task),  for 
   %        normalizing A columns in BS resamples and in BS-DISP
   % row 3  (unused, for task # 1)
   % rows 4-numtasks+2: adjustment coefficients of all BS resamples of BS-DISP 
 defarr constfact, ANORMWG[n1,np];   
   % Weights for computing the weighted mean of AA columns,
   %.. needed for normalizing AA columns.
   % For standard PMF, ANORMWG[0,0]=1;
   % For customary BS, ANORMWG[j1,0]=BSCOUNTS[j1,0];
   % In all these cases, sum of ANORMWG is = n1. 
   % For the scale-invariant case, sum of ANORMWG is not = n1. 
   
 defarr scriptdata, XXTRUE[n1,n2];  % Only for simulations
   % Not needed by the script. Available for experimentation.
   
 defarr scriptdata, ROWPULLIND[n1];  
   % Indicate which rows have special treatment in bootstrap:
   % =1 for "unsampled" XX rows whose weight has not been increased  
   % =2 & =3 for rows that contain a pulled AA element (down or up) 
   % =0 for other rows (i.e. "normal" sampled non-pulled rows)
   %    and when using DISP instead of BS for error estimation
   % Must be defined in non-BS because is checked if dotable>0
   
 defarr freefact,  AA[n1,np];   
            % Source contributions (>= alowlim) for the PMF2 model 
 defarr freefact,  BB[n2,np];   % Source profiles (>= 0) for both models 
 defarr freefact,  CC[1,np];   % Source strengths for PMF2 model 
  % "A*C*B":  AA columns are normalized to unit average 
  %           BB columns are normalized to unit sum or unit average 
  %              or arbitrary user-defined sum
  % "A*B":    AA columns normalized to unit average, CC[0,0]=1.0 
 defarr freefact,  BBCC[n2+1,np], aliasfor, BB; 
  % ***** AA, BB, and CC must be the first three free factor matrices *****

 defarr scriptdata, FACTORUSE[np,numrowtyps];
   % User-specified table of factor usage.  FACTORUSE[0,0]=1 by default.
   % FACTORUSE[jp,rt]=1 if factor jp fits ("explains") rows of type rt,
   % otherwise, FACTORUSE[jp,rt]=0.
 defarr scriptdata, QMCONTRIB[numrowtyps];
   % Contributions to Qmain from different row types.
   % Computed only if numrowtyps>1

 defarr scriptdata, AAKEYLOHI[n1,np,3]; %save AA.fkey, AA.flow, AA.fhigh
 defarr scriptdata, BCKEYLOHI[n2+1,np,3]; 
   % save BB.fkey, BB.flow, BB.fhigh, also the same CC controls for ACB model

 if> (numpf>0.5); 
   defarr auxdata,    PFNORM[np,numpf];            % for normalizing PF 
   defarr auxdata,    PFSMOO[maxpfdim,np,numpf];   % for smoothing PF 
   defarr auxdata,    CIRCULAR[numpf];   % =1 for circular parameters
                                         % such as season, wind direction
   defarr scriptdata, PFSMOOC1[maxpfdim,np,numpf];   %.. C1 for same 
         %.. PFSMOOC1[1,0,0] = C1 for circular smoothing (first vs last)
         %.. PFSMOOC1[ii,0,0] = C1 for smoothing element ii vs. element ii-1
   defarr auxdata,    PFPULL[maxpfdim,np,numpf+1];    % for pulling PF --> 1 
   defarr scriptdata, PFPULLC1[maxpfdim,np,numpf+1];  %.. C1 for same
   defarr scriptdata, PFUSED[maxpfdim,numpf+1];     %=1 for used PF elements
   defarr freefact,   PF[maxpfdim,np,numpf+1]; 
   defarr freefact,   CM[1,np];   % Source strength coeff for param. model
   defarr sefact,     MM[n1,np];   % MM is the model-based "left" matrix 
    % MM is implicitly normalized because all components of the parametric model
    % are normalized. Hence, a separate strength factor CM is needed.
   defarr scriptdata, PFDIM[numpf];
      % Numbers of classes for each parametric variable, = numbers of
      % parametric factor elements for each parametric variable 
   defarr scriptdata, PFIND[n1,numpfind];
      % Matrix of indices to parametric factors, generated by GUI
   defarr scriptdata, AAMC1[n1,np];    % C1 values for AAM 
   defarr scriptdata, AAMC3[n1,np];    % C3 values for AAM 
   defarr scriptdata, AAMSRES[n1,np];   % scaled residuals of AAM, for output
 if!;
 
 if> (aeruse==1);
   defarr freefact,   AERPENE[numaerc,np,2];   
      % Infiltration coeff. for outdoor factors, at most numaerc AER classes
      % Pages are for indoor and personal samples
   defarr auxdata,    AERCONS[n1,np];   % Equations for AER constraints
                                        %.. generated for sample types 2 and 3
   defarr scriptdata,  AERCLASS[n1];    % Air Exchange Rate classification codes                                    
   defarr scriptdata,  AERCONSRES[n1,np];   % scaled residuals of AERCONS, for output
 if!;
  
 defarr scriptdata, WTEMP[n2+1,np];   % Temporary storage for BB & CC, e.g. for output
 defarr scriptdata, WTEMPBB[n2,np], aliasfor, WTEMP;   % temp matrix for BB only
 defarr scriptdata, WTEMPACB[n2+acbmodel,np], aliasfor, WTEMP;   
      % Flexible temp matrix: alias for BB only if acbmodel=0, for BB and CC if acbmodel=1
 defarr scriptdata, SMALLDIA[3+dispdqlevs,np];   
    % Counts cases where factor identities appear changed
    % DISP: compares perturbed matrix G with best-fit matrix G
    % [1,0] Temporary table of swaps (row 1)
    % [2,0] Cumulative statistics of swaps (of 2 or more factors) over whole run 
    %       Includes all displacements, also displacements that have been rejected
    % [3,0] Copy of the last such version of row 1 that indicated 2+ swaps
    % [4,0] ..          Whole-run summary of swaps in failures to reach each dQmax
    % [3+dispdqlevs,0]  Failure = (swap of 2+ factors) or (exceeding max # of disp's)
    % BS: Compares pulled matrix G (sampled rows only) with the  
    %     unpulled G of same resample (same sampled rows)
 defarr scriptdata, BADCOUNTS[dispdqlevs];   
   % Counts of bad estimates for each dQmax (includes swaps,  not bad gradients)
 defarr scriptdata, DISPREJCNT[3];   
   % Counts of rejects in BS-DISP: local minima, best-fit swaps, DISPing swaps
 
 defarr scriptdata, SWAPTABLE[numtasks,6];   
     % list of tasks where identities of factors may have been swapped
 defarr scriptdata, CISUMMARY[4,3,4];   % Statistics over CI lengths
     % One page (dim: 4x3) for each dQmax
     % Columns: 1 = minim, 2=mean, 3=max
     % Rows: 1: averages over F CI row min/mean/max.  
     %       2: averages over F CI column min/mean/max.
     % 3: averages over rows 1 and 2 of this table
     % 4: averages over C CI min/mean/max. 
 
 if> (errestmode~=0);                      % DISP arrays are also used for BS output
   defarr scriptdata, BESTGRAD[n2+1,np];   % Best-fit BB/CC gradients
   defarr scriptdata, DISPBCMASK[n2+1,np]; % MASK=1 for perturbed BB/CC elements
   defarr scriptdata, DISPDQMAX[dispdqlevs];  
     % dQmax "level" values as input from iniparams.txt (dQ referred to best-fit Q)
   defarr scripttext, DISPDQHEAD[dispdqlevs,2]; 
     % col 1: header texts for Conf-Interval tables, e.g. "dQmax=10", "dQmax=20",...  
     % for DISP, so that CI length increases with list. For BS, might be
     % # of extreme value, so that most extreme (#1) comes last.
     % col2: file names for files where BS-DISP results of different dQmax are written                              

   defarr scriptdata, DISPLTABLE[dispmxnum+1,7]; 
     % For current displaced variable: for best-fit(col1) and for displacements (cols2..)
     % Displaced factor values       [0,1]   >= .flow   
     % Displacement steps            [0,2]   <0 or >0 
     % Actual cumulat. displacements [0,3] Set in preproc, right before iteration
     %       indicated wrt. best-fit value (not wrt. previous displacement)
     % Computed gradients            [0,4]   Set in postproc of all but first task
     % Computed dQ (=Q-Qbest)        [0,5]   Computed in postproc of all but first task from
     %                                   .. quadratic approximation of gradient vs. dQ
     % Factor swapping indicator     [0,6]   Computed in postproc,  = # of such T1 columns 
     %                            where diagonal is < dispswap1*max_of_column or < dispswap2
     % Correction to computed dQ     [0,7]   Based on # of constrained factor elements
     % Temp storage: [1,6] is = last error code seen. If dQmax is not reached, its error
     % indicator will be taken from DISPLTABLE[1,6] 
     
   defarr scriptdata, DISPBC1STP[n2+1,np,3];  
   % This array controls the first displacement to be tried for any factor element
   % DISPBC1STP[j2,jp,1] will contain the smallest or most negative value achieved 
   % for BC[j2,jp] (for this resample, if BS-DISP) while dQ is still < DISPDQMAX[1] 
   % DISPBC1STP[j2,jp,2] will contain most positive value for BC[j2,jp] while dQ<DISPDQMAX[1]
   % DISPBC1STP[j2,jp,3] will contain minimal displacement values (>0), based on
   %   FC values and computed single-variable uncertainty estimates HINVDIABC
   %   from the (full-data???) best fit.
     
   defarr scriptdata, DISPBCMIX[n2+1,np,dispdqlevs,6];   % used both for BS and for DISP !!!
     % When used for BS as "DISPBCMX",  only slices 1 and 2 (of 6) are used.
     %   Then third index=dispdqlevs contains most extreme values (longest CI),
     %   down to third index=1 which contains the dispdqlevs'th extreme values, 
     %   i.e. shortest listed CI, in analogy to short and long CI's with DISP.
     % Main use is with DISP and BS-DISP. Contains BBCC min values in 4th index=1,3,5 and
     %   max values in 4th index=2,4,6. May use "dispud" as part of 4th index for min/max 
     %   selection.  With DISP, 4th index=1,2 may contain indicator values 
     %     (=+-999.999 or +-777.777, indicating a not-estimated factor element)
     % 4th index=1,2: Interpolated displaced values, i.e. only the selected displaced
     %    BB & CC elements are estimated here.
     % Another pair, 4th index=3,4 values of BB & CC are evaluated using interpolated 
     %   values of both non-selected and selected BBCC factors. 
     %   For the non-selected elements that are not actively displaced, interpolated 
     %   conf-intervals may be somewhat shorter than those obtained if actively displacing 
     %   those variables. There are no not-estimated indicators in 4th ind=3,4 because 
     %   all factors are initialized to best-fit values and then estimated.
     % Downweighted variables: Not displacing them may provide more realistic estimates
     %   because active displacements might move them too far.
     % For BS-DISP, the values are evaluated over one resample only, then the values are 
     %   written and reset for next resample.
     %   The following was never implemented:  
     %      Yet another set of min and max values are evaluated by BS-DISP into 
     %      (4th index=5, 6). These are collected over all resamples (including also the 
     %      full-data values) using all values computed in (4th index=3, 4)
     %      These values are probably not so useful because they are the extreme values
     %      and hence not robust against even a single loss of factor identities
     %   Yet another set of min and max values are evaluated by DISP and BS-DISP into
     %   (4th index=5, 6). These are min and max estimates of column-scaled F values.
     
     
   defarr scriptdata, DISPBCMX[(n2+1)*np,1,dispdqlevs,6], aliasfor, DISPBCMIX; 
                 % This alias name is used by BS when preparing results for output
   defarr scriptdata, DISPBCINT[n2+1,np,dispdqlevs];
     % Initially during DISPing each variable:
     % Fictitious BBCC values, interpolated during DISP & BS-DISP estimation
     % PREVOKBBCC[0,0] are the values for last accepted displacement, 
     % and DISPBCINT[0,0,kk] are the interpolated values corresponding to dQmax[kk],
     % interpolated between PREVOKBBCC[0,0] and BBCC[0,0]
     % After the initial values have been stored:
     % initial values scaled so that each "F column" or "BB row" [j2,0,dl]
     % is scaled so that the sum of values is =1. (Scaling coefficients are discarded.)
     % These scaled values are used for F importance estimation in DISP and BS-DISP.
     % They are probably only useful in the case (G column average =1, acbmodel=0).
     
   defarr scriptdata, DISPSTATS[n2+1,np,dispdqlevs,4];  % Violation and error indicators
     % = 1 for each true BB & CC value violating each level of computed CI's either
     %     up (last_index = 2) or down (last_index = 1)   (use dispud as index)
     % = error code for failed/suspect estimations up (last_ind=4) or down (last_ind=3)
     %     >1 : # of swapped factors    
     %     -1 : displacements do not reach dQ  (not a failure)
     %                    Not used:  -2 : negative gradient cannot be avoided
     %     -3 : Q increases too steeply
     %     -4 : max # of disp steps exceeded  (?)
   defarr scriptdata, DISPBCHIQ[n2+1,np,2];  % Highest dQ reached for each factor element
     %.. when displacing up (last_ind=2) and displacing down (last_ind=1)
     % Coding for special cases, where actual obtained highest Q is not meaningful:
     % Instead of Q, store code values as follows:
     %   if border_step (outdisp=1),  codevalue = DISPDQMAX[dispdqlevs] + 2
     %   if failed high_Q_step,       codevalue = DISPDQMAX[dispdqlevs] + 1

   if> (errestmode<-1.5);                  % For DISP and BS-DISP
     defarr scriptdata, BESTBB[n2,np];     % Needed only for DISP and BS-DISP. For BS-DISP, 
     defarr scriptdata, BESTCC[ 1,np];     %.. BESTBBCC = best solution for the resampled data set
     defarr scriptdata, BESTBBCC[n2+1,np], aliasfor, BESTBB;
     defarr scriptdata, PREVOKBBCC[n2+1,np]; % Previous accepted solution, used  
                                             %.. for interpolating in DISP, BS-DISP
   if!;
 if!;

 defarr scriptdata, XXC1[n1,n2,2];    
   % page 1: XX.C1 values, as read from file and/or modified by the user 
   % page 2: XX.C1 values after (bootstrap) adjustments for weighting
 defarr scriptdata, XXC3[n1,n2,2];   
   % pages 1 & 2: as above, for XX.C3 values 
 
 defarr scriptdata, COLUMNAVG[n2];          % Approx. averages of XX columns
 
 defarr scriptdata, BESTFACTS[numfreef];    % For BS and DISP: the best=unperturbed solution  
              % For BS-DISP: best=unperturbed solution of the current resample (or full data) 
 defarr scriptdata, BESTAA[n1,np], aliasfor, BESTFACTS;  % Needed by BS if samplevari==2
 defarr scriptdata, OKDISFACT[numfreef];   % The latest accepted displaced factors
 
 defarr scriptdata, TRUEFACTS[numfreef];  
   % In simulations, TRUEFACTS  = generated "true" factors
   % In DISP displacements, if bsinitfact==1,   = initial values (should be "true")
 defarr scriptdata, TRUEAA[n1,np];          % For simulations, = true AA matrix
 defarr scriptdata, TRUEBB[n2,np];          % For simulations, = true BB matrix 
    % For DISP runs with bsinitfact==1, TRUEBB is = initial BB.
    %     (then, true values should be used as initial values)
    % For other non-simu runs (e.g. DISP and multiple random starts), 
    %   TRUEBB is not true, but simply 1st best-fit BB.
    % Is used as reference for re-sorting factors in all other tasks. 
    % Only stored after 1st task of any run. 
 defarr scriptdata, TRUECC[1,np];        % For simulations, = true CC matrix 
    % Used similarly as TRUEBB
 defarr scriptdata, TRUEBBCC[n2+1,np], aliasfor, TRUEBB;
 if> (simu>0);
   defarr scriptdata, SIMUTABLE[np,5,2];  
    % SIMUTABLE controls simulation of "true" factor matrices AA and BB
    % (except if readtruef==1 or ==2)
    % Row SIMUTABLE[jp,0,1] controls column jp of AA, as follows:
    % SIMUTABLE[jp,1,1] and SIMUTABLE[jp,2,1] specify low and high limits
    % of uniformly  distributed random numbers, to be used as "default"
    % generated elements in column jp of AA.
    % fi=SIMUTABLE[jp,3,1] and la=SIMUTABLE[jp,4,1] specify that in 
    % column jp, elements fi, fi+1, ... la-1, la are to be zeroed.
    % set fi=0 and la=0 if such systematic zeroing is not desired.
    % SIMUTABLE[jp,5,1] specifies the number of randomly chosen "stray"
    % factor elements in AA column jp that will be set equal to zero.
    % Similarly, SIMUTABLE[jp,1,2] to SIMUTABLE[jp,5,2] control the
    % generation of column jp of BB.
    % After the columns have been generated as explained above, 
    % (or input as such because readtruef==1 or ==2,)
    %   AA columns are normalized to average=1,    and 
    %   BB columns are kept as generated/input, except that in A*C*B model,
    %   they are normalized. BB normalization coefficients are stored in CC.
    % Thus SIMUTABLE[jp,1,2] and SIMUTABLE[jp,2,2] control "strength" of
    % factor jp: small values in them generate a "weak" factor.
 if!;
 
 defarr scriptdata, AAFSTPINV[n1,np];  % AAFSTPINV is transposed pseudoinverse
   % - of first AA matrix (i.e. first random-start matrix in repeated random starts
   %                       and best-fit matrix in DISP and BS-DISP error estimations)
   % - of resampled unpulled AA matrix in BS error estimation
 defarr scriptdata, AATAA[np,np];      % Matrix AA(transp) * AA and its inverse 
   % Used for temporary storage by FPEAK and by DISP when computing AAFSTPINV
 if> (dofpeak>0.01);   
   defarr scriptdata, FPEAK[np,np];     % Matrix of FPEAK parameters 
   defarr scriptdata, FPEAKSRES[n1,np]; % Scaled res. of FPEAKPULL, for output
 if!;

 defarr scriptdata, HINVDIAG[numfreef];     
    % Inverses of square roots of diagonals of Hessian, computed for full-data best-fit. 
    % Used in testing if factor value differs from its low-limit value
    % They are error estimates of individual factor elements in the situation
    % where all other factors are considered fixed.
 defarr scriptdata, HINVDIABC[n2+1,np];   % Same, only for BBCC. Different zero protection!  
 defarr scriptdata, MINMAXFACT[numfreef,2*numextrem,splitBSres];
    % Will contain smallest, 2. smallest, ..., 2. largest, largest BS values
    % computed for each A and B factor element.
    % These values constitute the endpoints of BS confidence intervals
 if> (dotable>0.5);
%  defarr scriptdata, RESLT[numfreef,10,splitBSres];
%      % RESLT is not used for DISP or BS-DISP!
% else; 
  defarr scriptdata, RESLT[numfreef,numtasks,splitBSres]; 
      % Stores the results of certain simulations 
      %.. and of all BS replications (both real and simulated data)
  defarr scriptdata, TASKTEMP[numtasks];
      % Temporary storage for sorting task-related values
      % Used by Minmaxsetx{}
 if!;
    
 if> (bsmode==14);      
   defarr scriptdata,  XXSAVE[n1, n2];   % A copy of the original XX
   defarr scriptdata, BESTFIT[n1, n2];   % Best fit of XX (from task 1) 
 if!;
       
% Mainly for analyzing results of BS simulation runs:
% ---------------------------------------------------
 defarr scriptdata, CONFILEN[2,numextrem];
   % Average lengths of A ([1,0]) and B ([2,0]) confidence intervals (CI) 
 defarr scriptdata, VIOLCOUNTS[2,2*numextrem]; 
   % Number of violations of each A ([1,0]) and B ([2,0]) CI
 defarr scriptdata, QTABLE[numtasks,4];        % Qm, Qa, Q(XX), backslope
 defarr scriptdata, SEEDS[5];        % For writing initial seeds
 defarr scriptdata, CORREL[np,np];   % Cross correlation matrix of
   % computed vs. "true" B columns. Also used for coefficient matrix
   % for approximating other AA matrices by the first AA matrix                                   
 defarr scriptdata, CORREL2[np,np];   % Used for testing and debugging
 defarr scriptdata, CORRTABLE[numtasks,np];  
    % For each A or B factor, "correlations" between the current factor and
    % a reference factor. For BS and DISP, the reference is the full-data
    % best-fit result; for BS-DISP, for resampled best fits, reference
    % is full-data best-fit, and for displaced resampled fits, reference
    % is the corresponding resampled best fit.     
 defarr scriptdata, FSAMETYPE[np,np];  % is=1 by default
    % FSAMETYPE[jp,jq]=0 for such pairs jp,jq that must not be exchanged
    % when resorting factors. Used mainly for factor selection models
    % (when numrowtyps>1) but may be used in other similar situations.
    

% If errestmode=-3, open & read file BStoDISP.dat and define more arrays
% ----------------------------------------------------==================
if> (errestmode<-2.5);     % Initiate DISP phase of BS-DISP.  bsphase=0;
  openfile 53, 'BStoDISP.dat',  R,  'old',       20000;  %  
  read 53, ' ', nf;
  if> (nf~=numbfreef); stop 'Incompatible file BStoDISP.dat';
  if!;
  read 53, ' ', numbstasks;   % # of solutions in file BStoDISP
  
  defarr scriptdata, BSDISPRES[n2+1,np,dispdqlevs,numbstasks,4];   % Define -----
%  defarr scriptdata, BSDISPRESH[n2+1,np,dispdqlevs,numbstasks];   % arrays -----
     % This large array      (for EPA data,  e.g. size =
     % 50*8*3*50*4 = 240000) will contain all min [0,0,0,0,1] and 
     % max [0,0,0,0,2] estimates computed by BS-DISP (includes
     % both explicitly displaced and interpolated F&C estimates).
     % The second half will contain column-scaled-F estimates
     % in [0,0,0,0,3] (min) and  in [0,0,0,0,4] (max).     
     % If some resamples are rejected, entries from end of these
     % tables remain unused. The tables are initiated to large
     % values, thus the unused values get sorted to end of sort
     % (and ignored) when results are output at end of run
elseif (errestmode<-1.5); 
elseif (errestmode<-0.5);     
  stop 'errestmode=-1 is not supported since June 2009';
if!;
                                
% AA and BB are the factors, to be multiplied together in the 2-way model 
%  "A*C*B":  XX(i,j)  =  SUM_p AA(i,p) * CC(1,p) * BB(j,p) +  E(i,j)
% or "A*B":  XX(i,j)  =  SUM_p AA(i,p) * BB(j,p)           +  E(i,j)


% End of array definitions
% ---------------------------------------------------------------------- 



% Needed library routine(s) are incorporated in this script,
% in order to simplify file and directory handling in the 
% distribution of EPA PMF.
% ------------------------------------------------------------------- 

dummyarr maindata, WRITX;                
subroutine> Xwrite2{##1,tf}{WRITX};     % Modified version
local advance, t0, t1, t3, t7, t9, tx;
  advance=0;              %Xwrite2 requires advance=0. Restored at end.
  t1=Arrinfo{WRITX,1};    %number of rows in WRITX
  t0=Arrinfo{WRITX,0};    %number of indices in WRITX
  if> (t0==3);   t3=Arrinfo{WRITX,3};   %number of pages in 3-dim WRITX
  elseif(t0==2); t3=-1;                 %-1: WRITX is a matrix 
  else; stop 'When calling Xwrite2, array must have 2 or 3 dimensions';
  if!;
  for> t9=1:1:t3;      %Do only if t3>0, i.e. if WRITX has 3 indexes
    for> t7=1:1:t1;
      write tf, '(I6)', t7;
      write tf, ##1, WRITX[t7,0,t9]; 
      write tf, '(/)';
    for!;
    write tf, '(/)';
  for!;
  if> (t3==-1);       %Do only if t3=-1, i.e. if WRITX has 2 indexes
    for> t7=1:1:t1;
      write tf, '(I6)', t7;
      write tf, ##1, WRITX[t7,0]; 
      write tf, '(/)';
    for!;
    write tf, '(/)';
  if!;
subroutine!;   % End of subroutine Xwrite2


dummyarr scriptdata, TTFWRTT;
dummyarr scripttext, TTFHEAD;
subroutine> Fwrite2{fi,##1,##2}{TTFWRTT,TTFHEAD}; 
local u1, t1, t2, advance;        %##1 and ##2 are dummy, hence local 
advance=0;              %Fwrite2 requires advance=0. Restored at end.
t1=Arrinfo{TTFWRTT,1};  %number of rows in TTFWRTT
t2=Arrinfo{TTFHEAD,-2}; % t2==-2 corresponds to a missing TTFHEAD
for> u1=1:1:t1;
  write fi, '(/1X,I4)', u1;
  if> (t2==-2);  % Do not write title if TTFHEAD is missing
    write fi, ##2;
  else;
    write fi, ##2, TTFHEAD[u1];
  if!;
  write fi, ##1,  TTFWRTT[u1,0];
for!;
write fi, '(/)';
subroutine!;   % End of subroutine Fwrite2

dummyarr scriptdata, TTFWRTT;
dummyarr scripttext, TTFHEAD;
subroutine> Fwrite3{fi,##1,##2,tt}{TTFWRTT,TTFHEAD};
local u1, t1, t2, advance;
advance=0;              %Fwrite3 requires advance=0. Restored at end.
t1=Arrinfo{TTFWRTT,1};  %number of rows in TTFWRTT
t2=Arrinfo{TTFHEAD,-2}; % t2==-2 corresponds to a missing TTFHEAD
for> u1=1:1:t1;
  write fi, '(/)';
  write fi, '(1X,I4)', u1;
  if> (t2==-2);  % Do not write row title if TTFHEAD is missing
    write fi, ##2;
  else;
    write fi, ##2, TTFHEAD[u1];
  if!;
  write fi, ##1,  TTFWRTT[u1,0,tt];
for!;
write fi, '(/)';
subroutine!;   % End of subroutine Fwrite3

% Set up equations for pulling (to 1) all PF factors in EPA PMF
% This is NOT a general-purpose library routine!
% If pulling needs to be adjusted after Pull{}{} has been called, 
% it is essential to modify PFPULL.C1 values, not PFPULLC1 values!
subroutine> Pull{}{};
local 
  tp,  % number of source or "factor" 
  tf,  % number of param. variable
  i1;  % indexing the parametric factor elements
for> tp=1:1:np;            % for all factors
  for> tf=1:1:numpf+1;     % also for y/n variables
    for> i1=1:1:maxpfdim;      % Insert the pulling equations, only for
      if> (PFUSED[i1,tf]>0.5);             %.. used PF elements
        equ> PFPULL[i1,tp,tf], Data=1.0,  
               C1=PFPULLC1[i1,tp,tf],  C3=0,  errmod=-12;
          term> pos;  @PF[i1,tp,tf]; term!;    % pulled factor 
        equ!;
      if!;
    for!;
  for!;
for!;
subroutine!;   % End of subroutine Pull


% Set up equations for normalizing all (except for y/n) PF factors 
% in EPA PMF (only the used elements)
subroutine> Pfnorm{}{};
local 
  tp,  % number of source or "factor" 
  tf,  % number of param. variable
  i1;  % indexing the parametric factor elements
for> tp=1:1:np;            % for all factors
  for> tf=1:1:numpf;       % not for y/n variables
    equ> PFNORM[tp,tf], Data=PFDIM[tf], C1=pfnormc1, C3=0,  errmod=-12;   
      for> i1=1:1:maxpfdim;      % Insert the pulling equations, only for
        if> (PFUSED[i1,tf]>0.5);             %.. used PF elements
          term> pos;  @PF[i1,tp,tf];  @PF[i1,tp,tf]; 
          term!;    % pull sum of squares of factor elements to dimension 
        if!;
      for!;
    equ!;
  for!;
for!;
subroutine!;   % End of subroutine Pfnorm


% Set up smoothing equations for all (except for y/n)
% used PF factors in EPA PMF
% This is NOT a general-purpose library routine!
% If smoothing needs to be adjusted after Smooth{}{} has been called,  
% it is essential to modify PFSMOO.C1 values, not PFSMOOC1 values!
subroutine> Smooth{}{};
local       
  tp,  % number of source or "factor" 
  tf,  % number of param. variable
  i1,  % indexing the parametric factor elements
  d1;  % the actual length of the param. factor vector

for> tf=1:1:numpf;   % not for y/n  (y/n tf =numpf+1)
 for> tp=1:1:np;     % for all factors
  d1=PFDIM[tf];      % Length of the pf vector to be made smooth
  for> i1=2:1:d1;    % Insert the non-circular equations
                     % but only if both factor elements are used
    if> (PFUSED[i1,tf]>0.5 & PFUSED[i1-1,tf]>0.5 ); 
      equ> PFSMOO[i1,tp,tf], Data=0,  
             C1=PFSMOOC1[i1, tp,tf],  C3=0,  errmod=-12;
        term> pos;  @PF[i1-1,tp,tf]; term!;  % "left factor"  
        term> neg;  @PF[i1,  tp,tf]; term!;  % minus "right factor"        
      equ!;
    if!;
  for!;
  % Insert the equation for circular smoothing (d1 <--> 1)
  % for factors whose CIRCULAR indicator is =1.
  if> (PFUSED[1,tf]>0.5 & PFUSED[d1,tf]>0.5 & CIRCULAR[tf]>0.5); 
    equ> PFSMOO[1,tp,tf], Data=0,  
          C1=PFSMOOC1[1, tp,tf],  C3=0,  errmod=-12;
      term> pos;  @PF[d1,tp,tf]; term!;    % "last factor"  
      term> neg;  @PF[1 ,tp,tf]; term!;    % minus "first factor"        
    equ!; 
  if!;
 for!;
for!;
subroutine!;   % End of subroutine Smooth


subroutine> Minmaxsetx{pg}{};   
% Called after last BS task for updating BS summary
% there,  dotable>0.5
% Collect "numextrem" smallest and largest values from each row 
% of RESLT (i.e. for each free variable) into corresponding row 
% of MINMAXFACT.
% Minmaxsetx operates on page pg of RESLT and MINMAXFACT
% If splitBScod=2, call Minmaxsetx twice, with pg=1 and pg=2 !
% Ignore invalid RESLT values (=-999000 ??)

local tr, tj, tt;
for> tj=1:1:numfreef;
  TASKTEMP[0]=RESLT[tj,0,pg];   % Pick one row of BS results 
  Bsort{TASKTEMP[0]};           % sort row into ascending order
  tr=numtasks;                  % tr points to last loc. of sorted row
  for> tt=2*numextrem:-1:numextrem+1;
    MINMAXFACT[tj,tt,pg]=TASKTEMP[tr]; 
    tr=tr-1;     % retrieve largest remaining, advance pointer
  for!;
  tr=1;
  while> (TASKTEMP[tr]<-99900); tr=tr+1;  % Advance pointer until
  while!;             %.. tr points to a valid value in TASKTEMP
  for> tt=1:1:numextrem;
    MINMAXFACT[tj,tt,pg]=TASKTEMP[tr];   % retrieve smallest 
    tr=tr+1;          %.. valid remaining in TASKTEMP, advance pointer
  for!;
for!;

%local tx, tr, tj, tt;
%for> tj=1:1:numfreef;
%  tr=RESLT[tj,taskxcount,splitBScod];
%  if> (tr>-99998);   % At each time, the value to be tested/inserted is in tr
%    if> (tr<MINMAXFACT[tj,numextrem,splitBScod]); 
%             % Is this smallest or 2. smallest or .. or numextrem'th smallest?
%      for> tt=1:1:numextrem;
%        if> (tr<MINMAXFACT[tj,tt,splitBScod]);   % is test value smaller than stored value?
%          tx=MINMAXFACT[tj,tt,splitBScod];       % yes, retrieve previous value
%          MINMAXFACT[tj,tt,splitBScod]=tr;       % store test value in its place
%          tr=tx;               % store previous value for further processing
%        if!;
%      for!;      
%    elseif (tr>MINMAXFACT[tj,numextrem+1,splitBScod]);  
%                % Is this largest or 2. largest or .. numextrem'th largest?
%      for> tt=2*numextrem:-1:numextrem+1;
%        if> (tr>MINMAXFACT[tj,tt,splitBScod]);   % is test value larger than stored value?
%          tx=MINMAXFACT[tj,tt,splitBScod];       % yes, retrieve previous value
%          MINMAXFACT[tj,tt,splitBScod]=tr;       % store test value in its place
%          tr=tx;               % store previous value for further processing
%        if!;
%      for!;      
%    if!;  
%  if!;
%for!;
subroutine!;   % End of subroutine Minmaxsetx


subroutine> Prepare{}{};  
% This subroutine contains preparations that need to be executed 
% in section "Equations".
% This subroutine is executed before subroutines Pull and Smooth.
% If smoothing and/or pulling is to be modified within this routine
% (i.e. modifying the initial default settings), 
% it is essential to modify  PFSMOOC1 and/or PFPULLC1 values, 
% NOT  PFSMOO.C1 and/or PFPULL.C1 values!
local ti,tj,jp,jq,rt;

if> ( (file14ok==0)  &
      (numrowtyps>1.5 | dofpeak>0.01 | simu>0) ); 
  stop 'FACTORUSE, fpeak and FPEAK, and simulation need iniparams.txt';
if!;

         % Read remaining control codes from iniparams.txt  ******
FSAMETYPE[0,0]=1;                 % Default: all factors are of same type  
if> (numrowtyps>1.5);             % Read matrix FACTORUSE if needed
  read 14, ' ',  FACTORUSE[0,0];
  if> (rowtypecol==0);            %.. also, must read ROWCODES if they
    read 14, ' ', ROWCODES[0];    %.. are not included in matrix X
  if!;
  for> jp=2:1:np;         % Compare all pairs jp,jq of factor use patterns
    for> jq=1:1:jp-1;
      for> rt=1:1:numrowtyps;          % If use differs for any single rowtype,  
        if> (FACTORUSE[jp,rt] ~= FACTORUSE[jq,rt]);  %.. set sameness = 0
          FSAMETYPE[jp,jq]=0; FSAMETYPE[jq,jp]=0;    %.. in symmetric table
        if!;
      for!;
    for!;
  for!;
if!;
% If resorting should be prohibited between any pair jp,jq of factors, the user
% may here zero the corresponding elements [jp,jq] and [jq,jp] of FSAMETYPE


if> (dofpeak>0.01);       % Prepare for Fpeak, both for simu and for real
  if> (dofpeak>1.5);
    read 14, ' ', FPEAK[0,0];      % Read matrix FPEAK if needed
  else;
    read 14, ' ', fpeak;     % Read a scalar value fp for uniform FPEAK
    FPEAK[0,0] = fpeak;
  if!;
  for> ti=1:1:np;         % Store zeros in diagonal of FPEAK.
    FPEAK[ti,ti]=0.0;     % In this way, whole matrix may be filled with
  for!;                   % the same value for PMF2-style FPEAK
if!;
  
if> (errestmode<-1.5);  % Read "mask" codes and dQmax values controlling  
  for> jp=1:1:np;       %.. DISP estimation of BB elements
    for> j2=1:1:n2;     % Cannot read whole columns! CC codes!
      read 14, ' ', DISPBCMASK[j2,jp];
    for!;
  for!;                             
  DISPBCMASK[n2+1,0]=acbmodel;  % Estimate CC only if acbmodel is used
  read 14, ' ', DISPDQMAX[0], degfreedom;
if!;
  
if> (simu>0);
  if> (readtruef==0); read 14, ' ', SIMUTABLE[0,0,0]; 
  elseif (readtruef==1);   
    SIMUTABLE[0,0,0]=-777;  read 14, ' ', TRUEAA[0,0],TRUEBB[0,0];
  else;
    SIMUTABLE[0,0,0]=-777;
    for> jp=1:1:np;  read 14, ' ', TRUEAA[0,jp];
    for!;
    for> jp=1:1:np;  read 14, ' ', TRUEBB[0,jp];
    for!;
  if!;
if!;
  
read 14, ' ', iv; 
if> (iv ~= iniparamv);
  write 24, '(F12.4/)', iv,iniparamv;
  write  6, '(F12.4/)', iv,iniparamv;
  stop 'End Marker, above, at end of iniparams.txt is not right';
if!;

% AA and BB control values are generated early and stored in special
% safe storage. This enables that the values-in-use may later be 
% disturbed and it is possible to undo the disturbance by restoring 
% the original values from the safe storage. 
% To begin with, the only controls that get disturbed are
% - AA.fkey, manipulated in order to implement BS resampling:
%   unsampled rows of matrix get fkey=masked.
% - BB.fkey, set to locked state for the displaced element in
%   DISP error estimations.
% Safe storage is implemented now for all six controls, for just 
% in case.
AAKEYLOHI[0,0,1]=lolimit;    % AA.fkey
AAKEYLOHI[0,0,2]=alowlim;    % AA.flow
AAKEYLOHI[0,0,3]=10.0;       % AA.fhigh

BCKEYLOHI[0,   0,1]=lolimit;  % BB.fkey for A*B model
BCKEYLOHI[n2+1,0,1]=locked;   % CC.fkey for A*B model

BCKEYLOHI[0,0,2]=0.0;   % BB.flow and CC.flow
BCKEYLOHI[0,0,3]=10.0;  % BB.fhigh (and CC.fhigh) for simu>0 for A*B model
                        %.. This is not a strict upper limit
% for simu=0, BC.fhigh will be generated at start of preproc

if> (acbmodel);                 % for the A*C*B model only,
  BCKEYLOHI[0,   0,1]=lohilimits;  %.. BB.fkey   and
  BCKEYLOHI[0,   0,3]=bnorm;       %.. BB.fhigh for simu and non-simu
  BCKEYLOHI[n2+1,0,1]=lolimit;     %.. CC.fkey  for simu and non-simu
  BCKEYLOHI[n2+1,0,3]=10.0;        %.. CC.fhigh for simu>0  
if!;                            %.. This is a strict upper limit!


                         % Still within subroutine> Prepare{}{};
if> (simu>0.5 & c1>0.0); % Simulation with a valid c1 value:
  XX.C1[0,0]=c1;         % set c1 and c3 for all XX values
  XX.C3[0,0]=c3;    
  
else;             % Not simu, or simu with c1<=0.0 : read "everything"
  XX[0,0]=-999.9;           % Safeguard against empty cells
  XX.C1[0,0]=-999.9;
%Modified by YS
%if> (ntextcols>=1);

%%%% Read data values into array XX from file # 30  
%XX[0,0]=-999;  XXC1[0,0]=-999;   % Values set for missing data
tabiscomma=1;  % TAB required (or comma) after an unquoted string:
commalimit=1;  %.. a string containing space characters reads OK!
 
 if> (rowtypecol<0.5);     % No extra column: read whole of XX at once  
  	%%% Read header row of data table	
	read 30, ' ', TEXTCOLS[1,0];	
	for> j2=1:1:n2;
	read 30, ' ', BBHEAD[j2];
		if> (stdwithxx==1);  read 30, ' ', ##1;   % Ignore std head
		if!;
	for!;	 
  %%% Read data table itself
  TEXTCOLS[0,0]='no-text';
   for> j1=1:1:n1;     
 
   read 30, ' ',TEXTCOLS[j1,0];
%  if> (numid2col>0); 
%    SAMPLEHEAD[j1]=TEXTCOLS[j1,numidcol],TEXTCOLS[j1,numid2col];
%  else;  
    SAMPLEHEAD[j1]=TEXTCOLS[j1,numidcol];
%  if!;
	AAHEAD[j1] = TEXTCOLS[j1, 1];
  %if!;
	for> j2=1:1:n2;
    read 30, ' ', XX[j1,j2];
	%read 30, ' ', XX[0,0];
		if> (stdwithxx==1);  read 30, ' ', XX.C1[j1,j2];
%		else;
		%%% Read header row of error table
			%for> j2=1:1:n2;
%			read 33, ' ', BUHEAD[j2];
			%read 33, ' ', ##1;   % Ignore head of serial # column
		%%% Read error table itself
				%for> j1=1:1:n1;         % Read error data table
%				read 33, ' ', XXC1[j1,j2,1];
				%for!;
%			closefile 33;
			%for!; 	  
		if!;
	 
	 for!;
	 for!;
	 %for!;
  else;                     % Cope with extra column:
    ROWCODES[0]=777;        % Guard against missing values of ROWCODES
    re=Minval{rowtypecol,n2+1};
    for> j1=1:1:n1;         %.. read XX row by row
      for> j2=1:1:re-1; read 30, ' ', XX[j1,j2];  % Read XX values before rowcode
      for!;
      read 30, ' ', ROWCODES[j1];                 % Read rowcode of this sample
      if> (numrowtyps==1);           % If row typing is not used, ignore codes>1
        ROWCODES[j1]=Minval{1,ROWCODES[j1]};      % Code 0 is still honored!
      if!;
      if> (aeruse==1);
        read 30, ' ', ac;      % Read AER code right after rowcode
        AERCLASS[j1]=ac;
        if> (ac>numaerc | ac<0.0);
          stop 'bad Air Exchange Rate classification code';
        if!;
      if!;
      for> j2=re:1:n2;  read 30, ' ', XX[j1,j2]; 
      for!;                    % Read XX values following rowcode (& aercode)
    for!;
  if!;
  
  if> (modifcode==1);  
    for> j2=1:1:n2;          % This is the Palookaville version
      read 30, ' ', d1, d3;  % read C1 and C3 for this variable j2
      XX.C1[0,j2]=d1;
      XX.C3[0,j2]=d3;    
    for!;
  else;  
%    if> (c1<=0.0); read 30, ' ', XX.C1[0,0];  % This is the main
%    else;          XX.C1[0,0]=c1;            % path: non-simu non-Paloo,
	if> (c1>0.0); XX.C1[0,0]=c1;
    if!;                                     % both GUI and non-Gui
    XX.C3[0,0]=c3;                           % also for simu if c1<=0
  if!;
  closefile 30;
  %closefile 33;
  
  if> (numpf>0.5);    % If parametric model is used,...
    AAM[0,0]=0;
    AAM.errmod[0,0]=modelem;     % not needed here?
    AAM.C1[0,0]=modelc1;
    AAM.C3[0,0]=modelc3;
    PFPULLC1[0,0,0]=pfpullc1;    % Default C1 for pulling PF to 1
    PFSMOOC1[0,0,0]=pfsmooc1;    % Default C1 for smoothing PF 
  if!; 

  SAMPLEOK[0]=0;           % Assuming no parametric model
  if> (numpf>0.5);         % If parametric model is used,
    SAMPLEOK[0]=1;         %.. initially assume good samples.
    read 32, ' ', PFDIM[0], CIRCULAR[0], PFIND[0,0];      
       % Reading file pf_inds.txt.
    for> ti=1:1:n1;                           % Step through all samples
      if> (ROWCODES[ti]<0.5); SAMPLEOK[ti]=0;      % Invalid sample
      elseif ((Arrminval{PFIND[ti,0]}>-1000 & Arrmaxval{PFIND[ti,0]}<-998) 
            | (Arrminval{PFIND[ti,0]}>-0.4  & Arrmaxval{PFIND[ti,0]}<0.4));  
         % All parametric info is missing for this sample: all indices
         % are either =-999 or = 0
        SAMPLEOK[ti]=0;    % post the missing-param-indicator
      else; 
        if> (Arrminval{PFIND[ti,0]}<-0.4);   % Negative index values 
                        % not allowed except for -999 in all columns
          stop 'Negative index for a parametric variable';
        if!;               % Checking both parametric and y/n columns        
      if!;
    for!;
    for> tj=1:1:numpf;       % Check parametric-variable columns
      if> (Arrmaxval{PFIND[0,tj]}>PFDIM[tj]);
        stop 'Too large index for a parametric variable';
      if!;
    for!;
    for> tj=numpf+1:1:numpfind;      % Check y/n columns
      if> (Arrmaxval{PFIND[0,tj]}>1.4);
        stop 'Code for a y/n parametric variable > 1';
      if!;
    for!;
    closefile 32;
  if!;
if!;
closefile 4;
subroutine!;   % End of subroutine Prepare


dummyarr scriptdata, MYMATR;
dummyarr scriptdata, MYIND;     % MYIND is optional parameter
subroutine> Diagcheck{oc,t1,t2}{MYMATR,MYIND};  
% Check for diagonal dominance of (mostly cross correlation) matrices
% MYMATR is the square matrix to be checked
% Off-diagonality indicators (=1) will be written on first 
% row MYIND[1,0] if parameter MYIND is present
% oc is off-diagonal count, =0 if matrix is diagonally dominant
% t1 is comparison tolerance when comparing the diagonal entry vs. max of column
% t2 is acceptance threshold (lowest accepted value) for OK diagonal
local t3,t4;  oc=0;
t3=Arrinfo{MYMATR,1};        % t3 = number of rows in MYMATR
if> (Arrinfo{MYIND,-1}>-1);  MYIND[1,0]=0;
  for> t4=1:1:t3;    % t4 steps over columns of the matrix
    if> ( MYMATR[t4,t4]<t1*Arrmaxval{MYMATR[0,t4]} | MYMATR[t4,t4]<t2 );
      oc=oc+1;  MYIND[1,t4]=1;
    if!;
  for!;
else;  for> t4=1:1:t3;   
         if> ( MYMATR[t4,t4]<t1*Arrmaxval{MYMATR[0,t4]} 
             | MYMATR[t4,t4]<t2 );   oc=oc+1; 
         if!;
       for!;
if!;
subroutine!;    % typically,  t1=0.9, t2=0.5


% Find next BB/CC element to be displaced when
% performing dQ-controlled error estimation ("disp")
% --------------------------------------------------------------------
% postproc takes care of the current element, e.g. bypassing larger
% dQ levels if low limit has been reached. In contrast, Dispnext 
% looks forward, inspecting new elements and taking necessary action
% Also, Dispnext computes the first displacement into dispnow

subroutine> Dispnext {}{}; 
% Initially, call with dispstate=-3: Dispnext sets dispup=1;
% and later again with dispstate=-2: Dispnext sets dispup=-1.
% After initial calls, call with any dispstate>=-1 and previously 
% found values of dispj2 and dispjp.
% Advances dispj2 and dispjp till next elem to perturb, 
% bypassing masked elements (DISPBCMASK==0), 
% elements with .fkey==locked and .fkey==masked,  and 
% such BB/CC down-perturbations where the best-fit BB/CC value equals 
% low-limit BB.flow/CC.flow, and such BB/CC up-perturbations 
% where .fkey=lohilimits and best-fit BB/CC value equals .fhigh value
% Bypasses also if extreme value in DISPBC1STP equals the .flow or 
% the lohilimits-defined .fhigh value.    (same for DISP amd BS-DISP)
% Successful calls return dispstate=0
% If initial calls fail, returns with dispstate unchanged
% When BB and CC are exhausted, Dispnext returns with dispstate=-1  

 local dn, bc;     % dn means done, bc is best-fit BB or CC element
 dn=0; 
 if> (errestmode>-1.5);  stop 'Internal error, Dispnext called with bad errestmode';
 if!;

 if> (dispstate<-1.5); 
   dispj2=1; dispjp=0;     % Initial calls (-3:up, -2:down)
   if> (dispstate<-2.5); dispup=1;  dispud=2;      % Initiate up
   else;                 dispup=-1; dispud=1;      % Initiate down
   if!;
 else; dispstate=-1;       % If other calls exit with -1, it means "not found"
 if!;
 while> (dispstate<0 & dn==0);
   if> (dispj2>n2+1);    
     dn=1;                 % Last CC element was already processed!     
                           % exit with negative dispstate
   elseif (dispjp>=np);    % Requests next value of dispj2
     dispj2=dispj2+1;
     dispjp=0;             % Inspect this element next, continue the while loop
   else;
     dispjp=dispjp+1;        % This is a legal set of jp, j2 to inspect
     bc=BESTBBCC[dispj2,dispjp];
     fk=BBCC.fkey[dispj2,dispjp];             % This is still the unperturbed fkey
     if> (DISPBCMASK[dispj2,dispjp]==0        % if MASK=0 : skip this BB/CC element 
        | fk==masked | fk ==locked);          % if element is masked or locked, no displacements
       dn=0;  % dummy statement 
     elseif (dispup==1);                      % Up stepping,
       if> ( (DISPBC1STP[dispj2,dispjp,2] < (0.999*BBCC.fhigh[dispj2,dispjp]+0.001*bc))
             | fk ~= lohilimits );    % this element either is not limited from above,
         dispstate=0;                 %.. or has not reached the limit yet --> select it                                  
       else;              % Is limited, has reached the high limit. Copy to result table,
         DISPBCMIX[dispj2,dispjp,0,2]=BBCC.fhigh[dispj2,dispjp];    %.. max page (2),
         DISPBCHIQ[dispj2,dispjp,2]  =DISPDQMAX[dispdqlevs]+2.0;    %.. report signal dQ,
       if!;               %.. and skip 
     else;  % Down stepping                         
       if> ( DISPBC1STP[dispj2,dispjp,1] > (0.999*BBCC.flow[dispj2,dispjp]+0.001*bc) ); 
         dispstate=0;         % This element has not reached its low limit --> select it
       else;                    % Has reached the low limit. Copy to result table,
         DISPBCMIX[dispj2,dispjp,0,1]=BBCC.flow[dispj2,dispjp];     %..  min page (1),
         DISPBCHIQ[dispj2,dispjp,1]  =DISPDQMAX[dispdqlevs]+2.0;    %.. report signal dQ,
       if!;                 %.. and skip 
     if!;     % End of the multiway if-elseif-else
   if!;       % End of testing dispj2 and dispjp
 while!; 
 if> (dispstate==0);              % Dispnext: Initiate after successful selection
   FREEFACTS[0]=BESTFACTS[0];     % Needed by following iteration
                                  % For BS-DISP:  BESTFACTS = best factors of this resample
   OKDISFACT[0]=BESTFACTS[0];     % Initiate best accepted displaced solution
   DISPLTABLE[0,0]=0;            
   PREVOKBBCC[0,0]=BBCC[0,0];     % For interpolating the solutions at dQmax levels
   dispokmx=0.0; dispbadmin=0.0; 
   dispstpcnt=0;
   dispHQdone=0;   dispdQok=0.0;
   dispmindis=DISPBC1STP[dispj2,dispjp,3]; 
   gd=BESTGRAD[dispj2,dispjp];
   if> (dispup==1);     
     dispnow = Maxval{0.5*(DISPBC1STP[dispj2,dispjp,2]-bc), 2.0*dispmindis};
   else;
     dm=DISPBC1STP[dispj2,dispjp,1];                    % dm = Smallest achieved displaced value 
     dm=Maxval{dm,0.5*(bc+BBCC.flow[dispj2,dispjp])};   % limit to halfway between factor and flow
     dispnow = Minval{0.5*(dm-bc), -2.0*dispmindis};    %.. and still cut this to half
   if!;
   if> (gd*dispnow > 0.8*DISPDQMAX[1]);   % Increase of dQ, caused by initial 
                   %.. best-fit gradient "gd" in a step of length "dispnow",
     dispnow=0.8*DISPDQMAX[1]/gd;         %.. should not exceed 0.8*DISPDQMAX[1])
   if!;
   if> (dispup==1);  dispstep  = Maxval{1.5*dispstepxx*dispnow, 1.5*dispmindis};
   else;             dispstep  = Minval{1.5*dispstepxx*dispnow, -1.5*dispmindis};
   if!;
   
   DISPLTABLE[1,0]={
     BBCC[dispj2,dispjp],  % 1 original (best-fit) factor value
     dispstep,             % 2 Initial step
     dispnow,              % 3 Initial displacement
     gd,                   % 4 best-fit gradient value
         0,0,0};           % 5,6,7 =0
   dispind=1; di1=2;    % di1=dispind+1;
   NORMS.aux1[0,0]=0.0;   % Make sure that norm computations are initialized with each
                          % new disp-ed element (both A norms and also B norms, if used)
                          % Alternatively, norms could be reset in each new DISP task!
   SMALLDIA[3,0]=0;       % Reset swap indicators from displacing previous element
 if!;
subroutine!;      % end of subroutine Dispnext{}{}

% End of subroutine definitions
% ------------------------------------------------------------------- 




%                   File handling
% ------------------------------------------------------------------- 

$skiplines
summary of ##a to ##z string variables
used for file names        and file/path naming:
##b ##d ##m ##p  ##f           ##r

for formats, see beginning of postproc, approx line 3460       
 ##1 to ##9,  ##a 
     
 ##9 is format for standard *.dat tables, np values per row
 ##s  text naming correlation basis, matrices TRUEAA and/or TRUEBB:
      simulated true f.. vs. first-task best-fit  vs. 
      

for temporary storage:  
 ##2
 ##t   Init vs Best vs True

 ##u  for up/down message, several places, temporary storage
 ##7  message text "Best.fit with ...."


 summary of all files: 
  #      name             use
  4  'PMF_bs2.ini'      This .ini file, when in EPA PMF. The development
                        versions of this file will have individual names. 
 13, 'moreparams.txt'   User-def. pulling & controls (fkey,flow,fhigh) 
                        Opened in sect #1, read in sections #1, preproc 
 14, 'iniparams.txt'    Opened and read in the first section
 15, 'pmfstatus.txt'    Status for GUI. Handled in callback section
                        (constantly updated during the computations)
 16, 'pmfstop.txt'      Stop command file from GUI. Handled in callback. 
 17, 'pmfreport.txt'    Q-values etc, written in postprocessing section
                        (updated/closed after each task has finished)
 18, 'pmfkill.txt',     The kill command file ends both the waiting loop
                        of ME-2 and the .bat loop in the "Dos box". 
 24, 'ME2.log'          The default ME2 log file
 30  'pmfdata.txt'      The (main) data file (= input file)
 31  'bscounts.txt'     Bootstrap sampling counts, from GUI
 32  'pf_inds.txt'      Indices of parametric factors, from GUI.
 39  'PMF_prev_res.dat' Previous computed factors (machine-readable)
 40  'PMFres.txt'       The human-readable main output file
 41  'PMFres.rsd'       Unscaled and scaled residuals (output file)
 42  'PMFres.out'       Abbreviated results file (output file)
 48  'logres.txt'       Summary info of results (not used with GUI)
 49  'PMFres.dat'       Computed factors, machine-readable. For BS and DISP,
                        by default only 5 first tasks write .dat results.
                        You may modify the limit, see section postproc.
 51  'PMF_BS.dat'       Table of bootstrapped computed factors    -OR-
 51  'DISPest.dat'      Tables of Min and Max values of BB and CC factors
                        for DISP levels 1, 2,... dispdqlevs
 52  'BStoDISP.dat'     Writing BS results, intended for DISP phase of BS-DISP
 53  'BStoDISP.dat'     Reading BS results, by DISP phase of BS-DISP
 81.. 'BSDISPres1.txt'  BS-DISP results for different dQmax values,
 ..86 'BSDISPres4.txt'  may be any number "dispdqlevs" =1 ... =6
 81.. 'DISPres1.txt'    DISP results for different dQmax values,
 ..86 'DISPres4.txt'    may be any number "dispdqlevs" =1 ... =6
      files 81..86  are opened in postproc of 1st task of BS-DISP
      or DISP only

 List contains the default file names 'pmfdata.txt' (file 30), 
 'PMF_prev_res.dat' (file 39), % and 'PMFres' (files 40,41,49).
 Actual file names may be different because other names may be
 read into text variables ##d, ##m, and ##p, respectively.
$endskip



% Construct names for output files, open some files right now
% -----------------------------------------------------------
%                     file #   path\name   R/W  status    max_rec_length 
%                 openfile  17,    ##r,     W,  'replace',     200;
%                 File 17 will be opened when it is needed, in postproc
##2=##m,'.txt';   openfile  40,    ##2,     W,  'replace',    2000;
##2=##m,'.rsd';   openfile  41,    ##2,     W,  'replace',   20000;
##2=##m,'.dat';   openfile  49,    ##2,     W,  'replace',    2000;
##2=##m,'.out';   openfile  42,    ##2,     W,  'replace',    2000;
if> (contrun==1);
                  openfile  39,    ##p,     R,  'old',        2000;
if!;
if> (dotable>0.5 | errestmode<-1.5);
                  openfile  51,    ##b,     W,  'replace',   20000;
if!;

if> (errestmode>0.5 & readbscnts>0.5);      % Will read sampling counts  
 openfile 31, 'bscounts.txt',  R,  'old',   20000;  %.. prepared by GUI
if!;
if> (simu==0 | c1<=0.0); 
   % Open the main data file, containing XX (and maybe XX.C1)
                  openfile 30,     ##d,     R,  'old',   20000;
%				  openfile 33,     ##e,     R,  'old',   20000; 
if!;
if> (numpf>0);                % Will read indices of parametric factors 
  openfile 32, 'pf_inds.txt',  R,  'old',   20000;  %.. prepared by GUI 
if!;
if> (errestmode>1.5);   % For writing BS results, to be read by a follow-on DISP
  openfile 52, 'BStoDISP.dat',  W,  'replace',   20000; 
  write 52, '(I8/)', numbfreef, numtasks;  
  % Write # of free factors as a check, # of BS tasks including full-data fit
if!;


% Temporary construction for file opening, used for massive
% systematic simulation runs. 
% Not used with EPA PMF GUI
% -------------------------------------------------------------------
if> (gui<0.5); openfile  48,  'logres.txt',   W,  'unknown',    500;
if!;
% -------------------------------------------------------------------

section!;   %%%%%%%%%%% End of first section "defines"  %%%%%%%%%%%%%%%




$sealbegin 102


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section> equations;

QTABLE[0,0]=0;
SWAPTABLE[0,0]=0;
DISPREJCNT[0]=0;
SMALLDIA[0,0]=0;    % This is the only place where whole SMALLDIA is reset
ROWCODES[0]=1;      % Default settings, corresponding to the usual
FACTORUSE[0,0]=1;   %.. situation where all factors explain all rows
ROWDOWNWG[0]=1;     % For start-up downweighting of factor selection models
BSWEIGHTS[0,0]=1.0; % Default for non-errest runs
SEEDS[1]=seed1;SEEDS[2]=seed2;SEEDS[3]=seed3;  % Store original seeds for
SEEDS[4]=seed4;SEEDS[5]=seed5;        %.. later output at end of task/run
if> (aeruse==1);
  AERPENE.fkey[0,0,0]=locked;   
  % Default, will remain for unused elements whose value will be = 1.00                        
  AERPENE.flow[0,0,0]=0.0;   
  AERPENE.fhigh[0,0,0]=1.0;   
if!;
                            % Not needed???
if> (errestmode~=0);        % Setting defaults for the "no-iniparams.txt" case:
  DISPSTATS[0,0,0,0]=0;     % Reset violation counts and error indicators
  DISPDQMAX[0]={8.0, 16.0, 32.0, 64};
  DISPBCMASK[0,0]=1;            % Pull/displace all F elements but
  DISPBCMASK[n2+1,0]=acbmodel;  %.. estimate CC only with acbmodel
  DISPLTABLE[0,0]=0.0;
if!;

if> (errestmode<-2.5);       % for BS-DISP. Initialize for min and max.
  BSDISPRES[0,0,0,0,0]= 10000000000;    % These "signal" values will remain in all
        % unused positions. Hence, these positions will get sorted as last elements, OK.
%  BSDISPRESH[0,0,0,0]= 10000000000; 
if!;

callsubr Prepare{}{}; 
 % Reading has been moved over to subroutine Prepare, defined outside 
 % of the protected part of the script, so that modifications to 
 % read commands are possible. The subroutine may also be used for other 
 % preparations that require use of arrays and hence cannot be performed
 % in first section.

if> (errestmode<-1.5 & doresort==1);  % re-sorting computed factors would not make sense
  doresort=-1;                        %.. when factors are perturbed: cancel resorting
if!;                                  %.. request for DISP and BS-DISP


% Echo output of control parameters from iniparams.txt
% ----------------------------------------------------
for> fi={24, 40};
  write fi, '(//A/)', ' iniparams.txt control parameters';
  write fi, '(4X,A)',    ##d, ##e, ##p, ##m;
  write fi, '(/I8)',  modifcode, robust;
  write fi, '(F8.2)', posoutdist, negoutdist; 
  write fi, '(I8)',   precmode, numtasks, numoldsol;
  write fi, '(/)';
  write fi, '(I8)',    bsinitfact, bsmode;
  write fi, '(F8.1)',  simu+0.1*readtruef;
  write fi, '(/)';
  write fi, '(I8)',   contrun, errestmode, disprejthr;
  write fi, '(F8.2)', pullc1; 
  write fi, '(I8)',   readbscnts, samplevari;
  write fi, '(/)';
  write fi, '(F8.2)', alowlim; 
  write fi, '(I8)',   acbmodel;
  write fi, '(/,10I8)', SEEDS[0];
  write fi, '(/)';
  write fi, '(I8)',   n1, n2, np;
  write fi, '(F8.2)', c1, c3; 
  write fi, '(I8)',   em;
  write fi, '(/)';
  write fi, '(I8)',   numpf, numynpf, maxpfdim;
  write fi, '(F8.2)', modelc1, modelc3, pfpullc1, pfsmooc1; 
  write fi, '(/)';
  write fi, '(I8)',   rowtypecol, numrowtyps, aeruse, doresort, dofpeak;
  write fi, '(F8.2)', fpeak;
  
  write fi, '(//A/)', '  Other control parameters';
  write fi, '(A)',    '  bnorm, goodstart, fullprec  =';
  write fi, '(F8.2)', bnorm, goodstart, fullprec;
  write fi, '(/A)',   '  SortAcorr  =';
  write fi, '(I8/)',  sortAcorr;
  
  if> (errestmode==1);
    write fi, '(A/)',  '  G pulling for BS:  maxtopull, mintopulld, pulldist  =';
    write fi, '(F8.2)', maxtopull, mintopulld, pulldist;
    write fi, '(/)';
  if!;
  if> (errestmode<-1.5);
    write fi, '(A)',  '  DISP perturbations: coefficient degfreedom  =';
    write fi, '(F6.2,/)',     degfreedom;
    write fi, '(A)',  '       dispswap1, dispswap2 = ';
    write fi, '(F6.2)',       dispswap1, dispswap2;
    write fi, '(/)';
    if> (errestmode<-2.5);
      write fi, '(/A)', '  BS-DISP # of resamples (including base case) =';
      write fi, '(I8/)',  numbstasks;
    if!;
  if!;
  if> (simu>0);
    if> (readtruef==0);
      write fi, '(/A/)',  '  G simulation control table';
      write fi, '(5F8.2)', SIMUTABLE[0,0,1];
      write fi, '(//A/)',  '  F simulation control table';
      write fi, '(5F8.2)', SIMUTABLE[0,0,2];
    else;
      write fi, '(/A/)',  '  true G and F as input (not yet normalized)';
      callsubr Fwrite2{fi,'(30(1X,F8.4,:))', '(1X)'}{TRUEAA};
      callsubr Fwrite2{fi,'(30(1X,F8.4,:))', '(1X)'}{TRUEBB}; 
    if!;
  if!;
  write fi, '(//)';
for!;


%               Perform a few  checks
% -----------------------------------------------------
if> (equcnt>0.5);
  stop 'Equations defined outside the sealed region';
if!;
if> (numpf>4.5);
  stop 'Number of parametric variables (numpf) is too large';
if!;
if> (Arrmaxval{ROWCODES[0]} > numrowtyps+0.1);
$skipnotdef Xdebug
    write 6, '(F12.4/)', ROWCODES[1], ROWCODES[2], ROWCODES[3],
    ROWCODES[n1], Arrmaxval{ROWCODES[0]};
$endskip
  stop 'Illegal value(s) in column of row type codes';
if!;



%             Define main equations 
% ---------------------------------------------------
for> j1=1:1:n1;       % Define basic PMF equations, A*B or A*C*B,
                      % possibly enhanced by selective factor use
  rc=ROWCODES[j1];    % rc is rowcode for current row j1 of XX
  if> (rc>0.5);       % Skipping invalid rows (rc<=0) entirely
    for> j2=1:1:n2;
      equ> XX[j1,j2],   errmod=em;
        for> jp=1:1:np;
          if> (FACTORUSE[jp,rc]>0.5);       % Check factor use code
            term> pos; @AA[j1,jp]; @BB[j2,jp];
              if> (acbmodel);  @CC[1,jp]; 
              if!;
            term!;
          if!;
        for!;  % Closing jp loop over all np factors 
      equ!;
    for!;      % Closing j2 loop over XX row j1
  if!;     % Testing ROWCODES for valid row j1
for!; 
    
    
if> (aeruse==1);      % Define equations for AER modeling
 for> j1=1:1:n1; 
  rc=ROWCODES[j1];    % rc is rowcode for current row j1 of XX
  if> (rc>0.5);       % Skipping invalid rows (rc<=0) entirely
    if> (j1>1.5); r1=ROWCODES[j1-1];
    else;         r1=0;
    if!;
    if> (j1>2.5); r2=ROWCODES[j1-2];
    else;         r2=0;
    if!;
    if> (rc==2 & r1==1 | rc==3 & r2==1);   
      % This is indoors or personal  (2 or 3) and preceding outdoors is OK?
      for> jp=1:1:np;    % Do equations for outdoors-fitting factors
        if> (FACTORUSE[jp,1]==1 & FACTORUSE[jp,rc]==1);
          id=AERCLASS[j1];  % id = AER classification for this sample
          if> (id>0.5);     % id=0 indicates missing classification info
            equ> AERCONS[j1,jp], Data=0, C1=aerC1, C3=aerC3, errmod=-5;
              if> (rc==2);
                AERPENE.fkey[id,jp,1]=nolimits;
                term> pos; @AA[j1,jp]; term!;    % measured minus fitted =~ 0
                term> neg; @AERPENE[id,jp,1]; @AA[j1-1,jp]; term!;
              else;
                AERPENE.fkey[id,jp,2]=nolimits;
                term> pos; @AA[j1,jp]; term!;    % measured minus fitted =~ 0
                term> neg; @AERPENE[id,jp,2]; @AA[j1-2,jp]; term!;
              if!;
            equ!;
          if!;     % Testing id  
        if!;       % Testing FACTORUSE
      for!;        % j2 loop over columns on row j1
    if!;
  if!;     % Testing ROWCODES for valid row j1
 for!; 
if!;
    
for> j1=1:1:n1;            % Define main equations for the parametric model
  rc=ROWCODES[j1];         % rc is rowcode for current row j1 of XX
  if> (rc>0.5);            % Skipping invalid rows (rc<=0) entirely
    if> (SAMPLEOK[j1]>0.5);   % =0 if parametric model is not fitted at all
      for> jp=1:1:np;      % Only generate the parametric modeling 
                           % equation if factor element AA[j1,jp] is used
        if> (FACTORUSE[jp,rc]>0.5);
          equ> AAM[j1,jp],  errmod=modelem;
            term> neg; @AA[j1,jp];
            term!;
            term> pos; @MM[j1,jp];
            term!;    
          equ!;        
        if!;  
      for!;  
    if!;   % Testing SAMPLEOK for valid parametric information
  if!;     % Testing ROWCODES for valid row j1
for!; 


if> (numpf>0.5);
  PFUSED[0,0]=0;           % Default: all PF elements are unused

  % Subexpression factor equations for the parametric model
  % -------------------------------------------------------
  for> j1=1:1:n1; 
    rc=ROWCODES[j1];         % rc is rowcode for current row j1 of XX
    if> (SAMPLEOK[j1]>0.5);  % Only for valid samples with good param. info 
      for> jp=1:1:np; 
        if> (FACTORUSE[jp,rc]>0.5);
          seequ> normal, MM[j1,jp];
            term> pos;
              for> jf=1:1:numpf;  % Inspect indices of param factors 
                id=PFIND[j1,jf];
                if> (id>0.5);       % If indicator is >= 1, insert
                  @PF[id,jp,jf];    %.. the indicated factor element 
                  PFUSED[id,jf]=1;  %.. and mark it as used                
                if!;
              for!;
              for> jf=1:1:numynpf;    % Inspect indices of y/n fact (if any) 
                if> (PFIND[j1,numpf+jf]>0.5);  % If jf'th y/n indicator ==1, 
                  @PF[jf,jp,numpf+1];      %.. insert jf'th factor element  
                  PFUSED[jf,numpf+1]=1;    %.. and mark it as used                
                if!;
              for!;
              @CM[1,jp];   % Insert scale factor
            term!;
          seequ!;
        if!;           % Conditional on factor element AA[j1,jp] being used  
      for!;
    if!;      % Conditional on a valid good sample
  for!;  
if!; 


%              Define auxiliary (aux) equations
% ---------------------------------------------------------

% Generate user-defined equations for pulling AA elements
% -------------------------------------------------------
if> (numGpull>0);
  for> gp=1:1:numGpull;
    read 13, ' ', GPULLS.errmod[gp],   % EM code
      GPULLS.aux3[gp],   %expected change
      GPULLS.aux4[gp],   % target value or pull-to value
      ss, rw;            % ss is either s=std-dev
    if> (rw<0.9 & rw>-0.9); 
      stop 'Error in G pulling specifications';
    if!;
    GPULLS.aux1[gp]=ss;  %.. or Q change limit dQ, depending on EM
    if> (GPULLS.aux3[gp]==0.0); GPULLS.aux3[gp]=0.02;
    if!;         % Replace 0 as expected change by the default = 0.02.
    equ> GPULLS[gp], Data=GPULLS.aux4[gp], C1=ss, C3=0.0;
      while> (rw>0);  % read a term for the expression
        i1=rw;
        usedpullwg=usedpullwg+1;
        if> (usedpullwg>numpulcons);
          stop 'G-pull constant factors overflow reserved space';
        if!;
        read 13, ' ', i2, GFPULCONS[usedpullwg], rw;
        term> pos; 
          @GFPULCONS[usedpullwg]; @AA[i1,i2];
        term!;   % Possibilities for optimizing: Omit coefficient +1
                 % from the term.  Translate -1 into a "neg" term.
      while!;
    equ!;
  for!;
  if> (Arrmaxval{GPULLS.errmod[0]}>-4.5);
    stop 'Ilegal EM code for G pulling';
  if!;
if!;

% Generate user-defined equations for pulling BB elements
% -------------------------------------------------------
if> (numFpull>0);
  for> fp=1:1:numFpull;
    read 13, ' ', FPULLS.errmod[fp],  % EM code
      FPULLS.aux3[fp],   % expected change
      FPULLS.aux4[fp],   % target value or pull-to value
      ss, rw;      % ss is either s=std-dev or Q change limit dQ, 
                   % depending on EM. rw is the F factor # for 1st 
                   % term in the pulled expression
    if> (rw<0.9 | rw>np+0.5); 
      stop 'Error 1 in F pulling specifications';
    if!;
    FPULLS.aux1[fp]=ss; 
    if> (FPULLS.aux3[fp]==0.0); FPULLS.aux3[fp]=-rw;    % set indicator
    if!;            %.. for replacing 0 by 0.01* column average (later)
    equ> FPULLS[fp], Data=FPULLS.aux4[fp], C1=ss, C3=0.0;
      while> (rw>0);  % read a term for the expression
        i2=rw;        % F: first came i2= factor number (=column in ME-2)
        usedpullwg=usedpullwg+1;
        if> (usedpullwg>numpulcons);
          stop 'F-pull constant factors overflow reserved space';
        if!;
        read 13, ' ', i1, GFPULCONS[usedpullwg], rw;  % # of variable
        if> (i1<0.5 | i1>n2+0.5); 
          stop 'Error 2 in F pulling specifications';
        if!;
        term> pos; 
          @GFPULCONS[usedpullwg]; @BB[i1,i2];
        term!;   % Possibilities for optimizing: Omit coefficient +1
                 % from the term.  Translate -1 into a "neg" term.
      while!;
    equ!;
  for!;
  if> (Arrmaxval{FPULLS.errmod[0]}>-4.5);
    stop 'Ilegal EM code for F pulling';
  if!;
if!;


% Generate equations for pull-to-1 and for smoothing of
% PF factor elements of the parametric model
% -----------------------------------------------------
if> (numpf>0.5);
  callsubr Pull{}{};
  callsubr Smooth{}{};
  callsubr Pfnorm{}{};
if!;


for> jp=1:1:np;      % Define normalization equations
% Set weighted averages of columns of factor matrix AA to unity
% -------------------------------------------------------------
  x4=0;     % Will become the # of rows where this factor is used
            % Needed with sample type coding, such as in EPA I/E model
            % 2009-10-17
  equ> NORMS[1,jp], Data=1, C1=1, C3=0.0, errmod=-23;
    for> j1=1:1:n1;   
      if> (ROWCODES[j1]>0.5);
        if> (FACTORUSE[jp,ROWCODES[j1]]>0.5);
          term> pos; @ANORMWG[j1,jp]; @AA[j1,jp]; 
          term!;
          x4=x4+1;  % Counting row j1 as active with factor jp
        if!;
      if!;
    for!;       
  equ!;    
  NORMS.aux4[1,jp]=Maxval{x4,1};  % Target value for AA normalization
    % = n1 except for sample type coding when it is  
    % = # of active rows for factor jp   or 
    % = 1 if no active rows
                        
  
% (Only if A*C*B) Set sums of columns of BB equal to bnorm
% --------------------------------------------------------
  if> (acbmodel);
    equ> NORMS[2,jp], Data=1, C1=1, C3=0.0, errmod=-23;
%    equ> NORMS[2,jp], Data=bnorm, C1=0.005*bnorm, C3=0.0, errmod=-12;
      for> j2=1:1:n2;
        term> pos;  @BB[j2,jp];
        term!;
      for!;  
    equ!;  
    NORMS.aux4[2,jp]=bnorm;  % Target value for BB normalization
  if!;  
for!;

if> (errestmode<-1.5);
  NORMS.C2[0,0]=0.001;   % Request good precision of 0.1% for norms with EM=-23
else;
  NORMS.C2[0,0]=0.003;
if!;

% Rotational pulling (random and FPEAK) of AA elements:
% APULL for random rotations in Bootstrap runs (if needed)
% and FPEAKPULL for FPEAK rotations (if needed).
% Both for simulations and for analysis of real data
% -----------------------------------------------------------
% For clarity of indexing, generate equations for all AA elements.
% Equations pulling unused AA elements will never be activated
% for random rotational pulling.
ii=0;              % So far, all BS pulling equations are made idle
for> j1=1:1:n1;    
  for> jp=1:1:np;      % Set up pulling of A elements
    ii=ii+1;           % Values of ii correspond to pairs of j1,jp 
    if> (errestmode==1);
      equ> APULL[ii], Data=1, C1=100000000, C3=0.0, errmod=-12;
        term> pos; @AA[j1,jp];     % The element to be pulled
        term!;
      equ!;
    if!;
    if> (dofpeak>0.01);
      equ> FPEAKPULL[j1,jp], Data=1, C1=2, C3=0.0, errmod=-14;
      % C1=4 was also tested with GE: same convergence rate, same result.
      % Data values will be maintained dynamically in callback
        term> pos; @AA[j1,jp];     % The element to be pulled
        term!;
      equ!;
    if!;
  for!;
for!;


section!;  %%%%%%%%  End of section "equations"  %%%%%%%%%%%%

$sealend 565572010
% previous were 470472429, 650230417, 109924217, ...



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section> preproc;
if> (taskcount>1.5);  taskxcount=taskxcount+1;
if!;
if> (bsphase==-1); taskxcount=1;  % Initiating new resample in BS-DISP
if!;
if> (taskcount==1 );              % For all: normal Best-Fit, BS, DISP, BS-DISP
  setrand 5, poisson, seed5; 
     % Generator 5 will be used either for Poisson or for Uniform
     % random numbers, used for BS weights. Will not be reset, each
     % replication will use new values from the same original sequence
     % (could also be reset similarly as generator 4).
  
% If this run analyzes real data, process arrays XX, XX.C1, XX.C3
% --------------------------------------------------------------- 
  if> (simu==0);  
% Actual reading of XX and its errors has been done in subroutine Prepare,
% also, errors of AAM have been generated there.

% Perform here any modifications of XX.C1 and XX.C3 values !!!!
% (and also of AAM.C1 and AAM.C3 values, if parametric analysis). 
% (e.g. for downweighting some variables or measurements)
   
    for> j2=1:1:n2;       % loop over columns
      cn=0; sm=0;         % Compute approximate average of column
      for> j1=1:1:n1;
        if> (XX[j1,j2]>=0);
          sm=sm+XX[j1,j2]; cn=cn+1;
        if!;
      for!;
      % Protect against no valid values and non-positive sums
 %     COLUMNAVG[j2]=Maxval{sm,0.0001}/Maxval{cn,1};   % updated 2010-10-21
      COLUMNAVG[j2]=Maxval{sm,0.000001}/Maxval{cn,1};
      if> (acbmodel==0);                  % for A*B model, set default 
        BCKEYLOHI[j2,0,3]=COLUMNAVG[j2];  %.. BB.fhigh for non-simu data.
      if!;                                %.. Not a strict upper limit
    for!;
% Store XX.C1 and XX.C3 (original or modified by user) for future use
    XXC1[0,0,1]=XX.C1[0,0];
    XXC3[0,0,1]=XX.C3[0,0]; 
    if> (numpf>0.5);        % Similarly, store AAM.C1 and AAM.C3 
      AAMC1[0,0]=AAM.C1[0,0]; 
      AAMC3[0,0]=AAM.C3[0,0];
    if!;
    colavgsum=Arrsum{COLUMNAVG[0]};         % Non-simu, 1st task
    if> (acbmodel);
      BCKEYLOHI[n2+1,0,3]=colavgsum/bnorm;    % CC informative upper limits
    if!;
  if!;


% Preprocessing: Still taskcount==1
% Default KEY values have been set in subroutine Prepare{} that may be
% modified by the user.
% Read/safe-store AA.fkey, AA.flow, AA.fhigh (in transposed AA/GG order)
% ----------------------------------------------------------------------
  if> (readGcontr==1);
    for> jp=1:1:np; read 13, ' ', AAKEYLOHI[0,jp,1];  %AA.fkey
    for!;
    for> jp=1:1:np; read 13, ' ', AAKEYLOHI[0,jp,2];  %AA.flow
    for!;
    for> jp=1:1:np; read 13, ' ', AAKEYLOHI[0,jp,3];  %AA.fhigh
    for!;
  if!;

% Read to safe-store BB.fkey, BB.flow, BB.fhigh (in natural BB order)
% -------------------------------------------------------------------
  if> (readFcontr==1);                 % (i.e. in transposed F order)
    for> j2=1:1:n2; read 13, ' ', BCKEYLOHI[j2,0,1];
    for!;
    for> j2=1:1:n2; read 13, ' ', BCKEYLOHI[j2,0,2];
    for!;
    for> j2=1:1:n2; read 13, ' ', BCKEYLOHI[j2,0,3];
    for!;
  if!;  % Null values may be used in the file, e.g. in order to keep
        % the COLUMNAVG values that have been loaded into BB.fhigh
        % for the A*B model
  closefile 13;
% -------------------------------------------------------------

  
% Preprocessing: In case row codes are used: mask unused AA elements
% -------------------------------------------------------------------
  for> j1=1:1:n1; 
    rc=ROWCODES[j1];    % rc is rowcode for current row j1 of XX
    if> (rc>0.5);       % Process valid rows
      for> jp=1:1:np;
        if> (FACTORUSE[jp,rc]<0.5);    % Is this factor unused?
          AAKEYLOHI[j1,jp,1]=masked;   % Mask unused factor elements
        if!;                           %.. in the safe storage
      for!;
    else;                        % It is an invalid XX row
      AAKEYLOHI[j1,0,1]=masked;  % Mask the corresponding AA row
    if!;
  for!;  

% Control info loading commands were originally here. It should be done
% again for each new resample, for just in case. It could happen
% that a reject from earlier resample leaves something locked or
% otherwise wrong
  
  AA.fprecc[0,1]=np;   
  if> (acbmodel);
    if> (fullprec);           BB.fprecc[1,1]=n2*np+np;
    else;  CC.fprecc[1,1]=np; BB.fprecc[0,1]=np;
    if!;                     % CC.fkey[0,0]=lolimit; CC.flow[0,0]=0; -- set earlier
  else;
    BB.fprecc[0,1]=np;       % CC.fkey[0,0]=locked -- has been set earlier
  if!;
  
if!;     % Ending data reading and ABC initializations in 1st task


if> (taskxcount==1);
% Preprocessing: Retrieve control information from safe storage -- also for resamples
% -----------------------------------------------------------------------------------
  AA.fkey[0,0] =AAKEYLOHI[0,0,1];
  AA.flow[0,0] =AAKEYLOHI[0,0,2]; 
  AA.fhigh[0,0]=AAKEYLOHI[0,0,3];
  BBCC.fkey[0,0] =BCKEYLOHI[0,0,1];  % Will be overridden for pulling/DISPing
  BBCC.flow[0,0] =BCKEYLOHI[0,0,2]; 
  BBCC.fhigh[0,0]=BCKEYLOHI[0,0,3];
if!;


% Preprocessing:
% For the following: Best-fit, BS unpulled, DISP, BS-DISP resampled best fit, 
% If parametric model: initialize PF factors and PF.fkey, PF.flow
% --------------------------------------------------------------------------
% (Do not initialize for second task of each BS replication
%  nor for perturbed DISP tasks)
% PF factor element initializations may be overridden later, if 
% initial values are input from a file or if best-fit values are used.
if> (numpf>0.5 & bsphase<1.5 & bsphase>-1.5); 
  if> (taskcount==1);
    CM.fprecc[0,1]=np;
    PF.fprecc[0,1,0]=np;
  if!;
  CM.fkey[0,0]=lolimit;  CM.flow[0,0]=cmlowlim; CM.fhigh[0,0]=10;
  CM[0,0]=1.0;
  PF.fkey[0,0,0]=masked;  % Default for unused PF.fkey elements
  PF[0,0,0]=0;            % Default for unused PF factor elements
  PF.flow[0,0,0]=0.01;    % Low limit for all PF factor elements
                          % Use a small positive value instead of 0 ???
  PF.fhigh[0,0,0]=10.0;   % Informative upper limit                        
  for> jf=1:1:numpf+1;
    for> i1=1:1:maxpfdim;
      if> (PFUSED[i1,jf]>0.5);
        PF.fkey[i1,0,jf]=lolimit;  % Activate used PF elements
        PF[i1,0,jf]=1.0;           % Initial values for PF factor elements
      if!;
    for!;
  for!;
if!;


% If this is a simulation run: Create "true" factors AA, BB, and CC
% -----------------------------------------------------------------

if> ( simu==1 | (taskcount<1.5 & simu>1.5) ); 
  % True factors are generated according to specifications in SIMUTABLE,
  % using random values from generator 3
 
  setrand 3, uniform, seed3;    % Set seed for random number generator #3   
  if> (readtruef==0);  % for simu==1, readtruef is always ==0
    for> jp=1:1:np; 
      AA[0,jp]=(SIMUTABLE[jp,1,1] ? SIMUTABLE[jp,2,1]);
      BB[0,jp]=(SIMUTABLE[jp,1,2] ? SIMUTABLE[jp,2,2]);
      if> (SIMUTABLE[jp,4,1]>0);
        for> j1=SIMUTABLE[jp,3,1]:1:SIMUTABLE[jp,4,1];
          AA[j1,jp]=0;    % Zero indicated elements in column jp
        for!;
      if!;
      if> (SIMUTABLE[jp,4,2]>0);
        for> j2=SIMUTABLE[jp,3,2]:1:SIMUTABLE[jp,4,2];
          BB[j2,jp]=0;
        for!;
      if!;
      t0=0;
      while> (t0<SIMUTABLE[jp,5,1]);  % Insert stray zeros to AA
        j1=(1 ? n1);            % j1 is random index to AA
        if> (AA[j1,jp]>0);
          AA[j1,jp]=0;   t0=t0+1;
        if!;
      while!;
      t0=0;
      while> (t0<SIMUTABLE[jp,5,2]);  % Insert stray zeros to AA
        j2=(1 ? n2);            % j2 is random index to BB
        if> (BB[j2,jp]>0);
          BB[j2,jp]=0;   t0=t0+1;
        if!;
      while!;       % Still using random generator # 3
    for!;
  else;
    AA[0,0]=TRUEAA[0,0]; BB[0,0]=TRUEBB[0,0];
  if!;
  seed3=seed3+100;   % seed3 used for creating "true" factor values
  CC[0,0] = 1.0;
  
  for> jp=1:1:np;   
    ra=Arrsum{AA[0,jp]}/n1;       % Make true factors A normalized (sum = n1)
    Blincomb{AA[0,jp], 1.0/ra, AA[0,jp]};   % Compute column = column/ra
    % If not ACB model, B is left as it is now, not normalized, in order to
    % allow for factors of different strength
    if> (acbmodel);                 % Normalize BB and adjust CC accordingly
      rb=Arrsum{BB[0,jp]}/bnorm;    % rb is the adjustment coefficient
      Blincomb{BB[0,jp], 1.0/rb, BB[0,jp]};   % divide BB column and
      CC[1,jp]=rb*CC[1,jp];                   % multiply CC element by rb
    if!;
  for!;
  TRUEAA[0,0]=AA[0,0];
  TRUEFACTS[0]=FREEFACTS[0];  
    % CC and random AA & BB --> TRUEFACTS. This is only setting of TRUEFACTS.
  TRUEBBCC[0,0]=BBCC[0,0];
    % This is the only genuine setting of TRUEAA & TRUEBBCC, it is valid for 
    % all simu data. For real data, "TRUE..." factors are "faked",
    % they are replaced by initial or best-fit data, see below.
  ##s=' simulated true factors';
if!;   % End of generating true factors 
% ---------------------------------------------------------------------
%   Simulation (all cases simu>0): 
%   true factors have been generated (or read as such) and stored


% Preprocessing:  If this is a simulation run:
% Simulate XX: Create error-free matrix, add random noise 
% -------------------------------------------------------
if> (simu==1 | simu==2 | (taskcount<1.5 & simu>2.5));
  if> (c1>0.0);     % If c1<=0, the std-dev matrix XX.C1 has been input
    XX.C1[0,0]=c1;  % already in subroutine !
  if!;
  XX.C3[0,0]=c3;           % Now, XX.C1 and XX.C3 are ready in all simu cases
  XXC1[0,0,1]=XX.C1[0,0];  % Put them in safe store for BS
  XXC3[0,0,1]=XX.C3[0,0];  %..
  setrand 2, normal, seed2;  % Set the seed for random number generator #2 
  seed2=seed2+100;           % for generating noise, to be added to data  
  for> j2=1:1:n2;        % Generate data matrix XX with pseudorandom noise 
    for> j1=1:1:n1; 
      rr=0.0;
      for> jp=1:1:np;     % This is OK both for A*B and A*C*B models
        rr=rr +  AA[j1,jp] * BB[j2,jp] * CC[1,jp];
      for!;
      XXTRUE[j1,j2]=rr;
      rs=XX.C1[j1,j2]+c3*Abs{rr};       % rs is the std-dev (per c1 and c3) 
      XX[j1,j2]=rr+Nrandom{0.0,rs,2};   % Add Gaussian noise (stddev=rs) to
    for!;                               % simulated true data in XX
    COLUMNAVG[j2]=Arrsum{XX[0,j2]}/n2;
  for!;
  colavgsum=Arrsum{COLUMNAVG[0]};       % Simulated data
  if> (acbmodel);
    BCKEYLOHI[n2+1,0,3]=colavgsum/bnorm;  % CC informative upper limits
    CC.fhigh[0,0]=colavgsum/bnorm;        % into safe storage and to actual use
  if!;
if!;    
% End of generating (simulating) matrix XX with noise
% ---------------------------------------------------


% Preprocessing: Initial defaults for all cases, BS and non-BS, simu and non-simu 
% -------------------------------------------------------------------------------
if> (bsphase<1.5 & bsphase>-1.5);  % Best-fit tasks, also of BS-DISP,
                                   % and 1st task of each BS replications
  ROWPULLIND[0]=0;  % Default, indicates normal sampled rows, no pulling. 
                    % OK for simu=2, too! 
  BSCOUNTS[0]=1;  % Include all rows of matrix (no BS sampling) 
                  % Uses original XX.C1, XX.C3, and XX.errmod
                  % Used (also in non-BS cases) for initializing ANORMWG 
  BSWEIGHTS[0,2]=1.0;     % All rows are used
  XX.posoutdis[0,0]=posoutdist;  % only needed for BS
  XX.negoutdis[0,0]=negoutdist;  %..
  XXC1[0,0,2]=XXC1[0,0,1];  % Default C1: no weighting by bootstrap etc.
  XXC3[0,0,2]=XXC3[0,0,1];  % Default C3: ..
  if> (numpf>0.5);  
    AAM.posoutdis[0,0]=posoutdist;  % only needed for BS
    AAM.negoutdis[0,0]=negoutdist;  %..
  if!;
if!;
APULL.C1[0]=1000000;  % Makes previous pulls (if any) inactive


% Preprocessing:
% Do  resampling (weighting or residual modif.) for BS runs 
% or  read BSCOUNTS for BS-DISP
% ---------------------------------------------------------------
BSNORMADJ[2,0]=1.0;     % default: no NORM adjustment
if> (bsphase==1);       
     % Do not sample in task 1 (bsphase==0), it is the best-fit case. 
     % Keep previous sampling if this is the 2nd task of BS replication
  if> (readbscnts);              % Read BS sampling counts for one BS 
    read 31, ' ', BSCOUNTS[0];   %.. replication at a time
  else;          % Generate sampling counts as (Poisson?) pseudorandom
                 % values, with param = 1.0. Use generator # 5 
    if> (bsmode==15);  % Instead of Poisson, generate a two-valued
                       % distribution of BS weights. Use generator # 5 
      BSCOUNTS[0]=Urandom{0.0,1.0,5};
      ta=wgb/(wga+wgb);  % ta is probability of "a" weight alternative
      
      for> j1=1:1:n1;
        if> (BSCOUNTS[j1]<ta);   % Is it "a" or "b"?
          BSCOUNTS[j1]=1-wga;    % It is "a", set weight of case "a"
        else;
          BSCOUNTS[j1]=1+wgb;    % It is "b", set weight of case "b"
        if!;
      for!;  
    elseif (bsmode==14);   % Instead of Poisson, select 50% of BSCOUNTS[j1] 
      BSCOUNTS[0]=0;       %..  to be =2. Rest are =0.
      ii=0;
      while> (ii<n1/2);
        j1=Roundtonea{Urandom{0.51,n1+0.49,5}};  % select random value 1..n1 
        if> (BSCOUNTS[j1]<1);           % if it is off, turn it on and count 
          BSCOUNTS[j1]=2; ii=ii+1;
        if!;
      while!;
    else;              % Generate Poisson weights
      pr=1.0;
      BSCOUNTS[0]=Prandom{pr,5}; % pr = the Poisson parameter 1.0
    if!;
  if!;
elseif (bsphase==-1);          % BS-DISP initiating new resample
   read 53, ' ', BSCOUNTS[0],  % BSCOUNTS not read when taskcount=1 , i.e. when
     BSNORMADJ[2,0];           %.. analyzing full data for BS-DISP, bsphase=0   
   disprejsco=0;               % no rejects yet for the new resample     
if!;
  
if> (bsphase==1 | bsphase==-1);   
  BSWEIGHTS[0,1]=BSCOUNTS[0];  % {.. will be modified for bsmode 14

  if> (bsmode==14);     %  bsmode==14: restore equal weights (=1) 
    BSWEIGHTS[0,1]=1;
    for> j1=1:1:n1;     %  modify data for resample-on-residuals
      if> (BSCOUNTS[j1]>1.0);     % double this residual
        Blincomb{XX[j1,0],  2.0, XXSAVE[j1,0], -1.0, BESTFIT[j1,0] };
      else;                       % zero out this residual:
        XX[j1,0]=BESTFIT[j1,0];   % Replace data by best fit
      if!;             % (Pulling of all GG rows will be allowed)  
    for!;
  if!;

% Scale BSWEIGHTS[0,1] to sum = n1  (ANORMWG weights will be scaled later)
% (In standard BS, the weights by default add up to n1)
% Place 0/1 weights in BSWEIGHTS[0,2]
  rr=Arrsum{BSWEIGHTS[0,1]}/n1; 
  BSWEIGHTS[0,2]=1.0;
  for> j1=1:1:n1;        
    BSWEIGHTS[j1,1]=BSWEIGHTS[j1,1]/rr;
    if> (BSWEIGHTS[j1,1]<=0.0);
      BSWEIGHTS[j1,2]=0.0;    % Reset col 2 elements to 0.0 for unused rows
    if!;
  for!;   


% Preprocessing:
% Still BS with bsphase==1, or BS-DISP with bsphase=-1
% Perform the actual weighting of data matrix elements (undo previous
% weighting), mark unsampled rows (if any)
% --------------------------------------------------------------------
% Executed when bsphase==1, i.e. for 1st task of each BS replication
% and also for bsphase==-1, resampled-best-fit-task of BS-DISP
  for> j1=1:1:n1;             % Check BS weight for this row j1:
    if> (BSWEIGHTS[j1,1]<=0);   % This "if" may only occur with bsmode==11
                              % Do not compute a row whose weight is zero:
      AA.fkey[j1,0]=masked;   % Its factor elements will be zeroed out later.
      XX.errmod[j1,0]=-15;            % Its main data are made missing.
      if> (numpf>0.5 & rewgxxm>0.5);  % If reweighting AAM data, make
        AAM.errmod[j1,0]=-15;         % the AAM data of this row missing, too 
      if!;
      ROWPULLIND[j1]=1;          % Indicate that this row is unsampled 
      % The XX.C1, XX.C3, AAM.C1, and AAM.C3 values are left in unspecified
      % state for rows with zero weight. OK because unsampled data are 
      % made "missing". C1 and C3 will be restored once the row is sampled.
    else;  
      AA.fkey[j1,0]=AAKEYLOHI[j1,0,1]; 
         % Undo previous unsampling of AA and XX rows. If it is an invalid
         % XX row, AA.fkey will still be masked! 
      XX.errmod[j1,0]=em;      % .. restore original em of this XX row 
      sb=Sqrt{BSWEIGHTS[j1,1]};  
      sc=sb;
      if> (bsmode==14 & BSCOUNTS[j1]>1.0); sc=2*sb;
      if!;        % Increase outlier limit for data with doubled residuals 
      XX.posoutdis[j1,0]=posoutdist*sc;
      XX.negoutdis[j1,0]=negoutdist*sc;        
      for> j2=1:1:n2;
        XXC1[j1,j2,2]=XXC1[j1,j2,1]/sb;   % Modify C1 and C3 to reflect the
        XXC3[j1,j2,2]=XXC3[j1,j2,1]/sb;   % sampling count of this row
      for!;
      if> (numpf>0.5 & rewgxxm>0.5 & (bsmode==11 | bsmode==15) ); 
         % Only reweight AAM if there is sampling (=reweighting) of XX rows
         % Do not reweight AAM if residuals are manipulated (14)
         % or if pulling is used (13) 
        AAM.errmod[j1,0]=modelem;   % Restore orig. em for parametric model 
        AAM.posoutdis[j1,0]=posoutdist*sb;
        AAM.negoutdis[j1,0]=negoutdist*sb;
        for> jp=1:1:np;
          AAM.C1[j1,jp]=AAMC1[j1,jp]/sb;  % Similarly, C1C3 for parametric
          AAM.C3[j1,jp]=AAMC3[j1,jp]/sb;  % equations if reweighting them
        for!;
      if!;
    if!;
  for!;
if!;      % End of setting up BS resampling  (bsphase==1 or ==-1)


% Preprocessing: Implement random rotational pulling for Bootstrap (BS) runs 
% -------------------------------------------------------------------------- 
% Pulling is adjusted for AA factor values. Thus this section should
% only be executed after reasonable approximations of AA elements 
% are available, either BESTFACTS or AA. 
% AA elements corresponding to invalid XX rows are not pulled.
% Factor selection by using FACTORUSE is honored: unused elements
% are not chosen for rotational pulling.

% This was already executed!!!!
% APULL.C1[0]=1000000;  % Makes previous pulls (if any) inactive

if> (bsphase>1.5);   % Pull for 2nd task of each BS replication  --- never for BS-DISP
  seed4=seed4+100;  setrand 4, uniform, seed4;  
       % random numbers for picking up the elements to be pulled down
  numhp=0;   % At this point, no element is selected for pulling down or up
  while> (numhp<numpull);
    jj=Roundtonea{0.55 ? (n1*np+0.45)};  % Pick a random index of APULL 
    j1=Integerdiv{jj+np-1, np};     % j1=1, 2,...,n1
    jp=jj-(j1-1)*np;                % jp=1, 2,...,np. Pulling AA[j1,jp] ?
    rc=ROWCODES[j1];
    if> (ROWPULLIND[j1]==0 & BESTFACTS[jj]>mintopulld*Arrmaxval{AA[j1,0]} &
         BESTFACTS[jj]<maxtopull & rc>0.5);  
        % Check that:
        % (1) no element on this row has been chosen for pulling, 
        % (2) row is not rejected by bootstrap sampling,
        % (3) element to be pulled is larger than mintopulld * max-of-AA-row, and
        % (4) element to be pulled is not too large.
        % (5) row j1 is valid XX row
      if> (FACTORUSE[jp,rc]>0.5);
        % (6) element to be pulled is used for fitting
        % If OK, pull this element:
        numhp=numhp+1;
        APULL.C1[jj]=pullc1; APULL[jj]=BESTFACTS[jj]-pulldist; 
        ROWPULLIND[j1]=2;                 % Pull this one down
      if!;
    if!;
  while!;      % Elements have been selected for pulling down
  
  numhp=0;     % So far, no element is selected to be pulled up
  while> (numhp<numpull);
    jj=Roundtonea{0.55 ? (n1*np+0.45)};  % Pick a random index of APULL 
    j1=Integerdiv{jj+np-1, np};          % j1=1, 2,...,n1
    jp=jj-(j1-1)*np;                     % jp=1, 2,...,np
    rc=ROWCODES[j1];
    if> (ROWPULLIND[j1]==0 & BESTFACTS[jj]<maxtopull & rc>0.5);
      if> (FACTORUSE[jp,rc]>0.5);        % OK, pull this element
        numhp=numhp+1;
        APULL.C1[jj]=pullc1; APULL[jj]=BESTFACTS[jj]+pulldist;
        ROWPULLIND[j1]=3;                   % Pull this one up
      if!;
    if!;
  while!;      % Elements have been selected for pulling up
if!;  % End of pulling, performed only when bsphase==2


% Preprocessing: Set up BB/CC perturbation for DISP estimation - not 1st task
% ---------------------------------------------------------------------------
% Stepping parameters have been updated in postproc of previous task
if> (taskxcount>1 & errestmode<-1.5); 
  % Only for first level of each perturbation, Dispnext did initiate
  % with FREEFACTS[0]=BESTFACTS[0];  
  if> (dispstate==0);
    if> (dispup==1);  ##u=' element to perturb up:';
    else;             ##u=' element to perturb down:';
    if!;
    for> fi={24, 40};     write fi, '(///)';
      if> (dispj2==n2+1); write fi,'(A)', '  New C', ##u; write fi,'(I5)', dispjp;
      else;       write fi,'(A)', '  New F', ##u; write fi, '(I5)', dispj2,dispjp;
      if!;
      write fi,'(A)', '   =========================================';
    for!;
  if!; 
  % taskxcount>1, any dispind, errestmode==-2,-3: Lock and disturb chosen BB/CC element
  BBCC.fkey[dispj2,dispjp]=locked;    % Lock the selected element
  bc=BESTBBCC[dispj2,dispjp];         % Displacements are made with reference to best value bc
  outdisp=0; dispstpcnt=dispstpcnt+1;
  if>    ( (1.001*dispnow) <= (BBCC.flow[dispj2,dispjp]-bc) );
    outdisp=1;      %.. report that limit reached, obey the low limit!
    dispnow=BBCC.flow[dispj2,dispjp]-bc;
    dispstep=dispnow-dispokmx;
  elseif ( (1.001*dispnow) >= (BBCC.fhigh[dispj2,dispjp]-bc) 
            &  BCKEYLOHI[dispj2,dispjp,1]==lohilimits  );
    outdisp=1;      %.. report that limit reached, obey the high limit!
    dispnow=BBCC.fhigh[dispj2,dispjp]-bc;
    dispstep=dispnow-dispokmx;
  if!;
%  PREVBBCC[0,0]=BBCC[0,0];          % Store current BBCC for interpolations ERROR!!!!!!?????
                                     % This BBCC may not correspond to an accepted step
  BBCC[dispj2,dispjp]=bc+dispnow;    % performing original or limit-truncated step
                              % This is only place where displacement is actually effected
  dispgracut=0.1/Abs{dispnow}; dispgracnt=0;
     % This gradient limit corresponds to inc/decrease of Q <= 0.1 over the 
     % current step. Iteration will be interrupted in callback section after
     % abs-value of gradient falls below this limit a chosen number (5?) of times.
     % dispgracut is reset to zero at start of each postproc! 
  DISPLTABLE[di1,1]=BBCC[dispj2,dispjp];            % = displaced factor value   
  DISPLTABLE[di1,2]=dispstep;          % = actual executed displacement change = "step"
  DISPLTABLE[di1,3]=dispnow;         % = cumulative displacement, same as before
if!;  % if (taskxcount>1 & errestmode<-1.5); 


% Preprocessing: Generate initial values for free factor elements -- all cases  
% ----------------------------------------------------------------------------
if> (bsphase == 2);   
    % No initialization, i.e. keep old factors
elseif (errestmode<-2.5);          % Read factors from BS-DISP intermediate file
  if> (bsphase==0);  dispbsnumb=1;
    read 53, ' ', FREEFACTS[0];    % BS-DISP: read full-data best fit
    write 40, '(/A/)', 'Reading full-data best fit, a.k.a. resample # 0';
  elseif (bsphase==-1);            % BS-DISP: read resample best fit 
    dispbsnumb=dispbsnumb+1;       % count input of one resample
    read 53, ' ', FREEFACTS[0];    % Initiate from results obtained in BS phase
    write 40, '(///A)', '  Reading best fit for resample #';
    write 40, '(I6)', dispbsnumb-1;
    write 40, '(A/)', '   ################################';
  if!;                            
          % No BS-DISP initial values set after this point !!! ----------------------------------
elseif ( contrun==0 | simu==4 | (bsinitfact==1 &    % testing for simu=4 is redundant?????
       taskxcount>1.5 & errestmode>0.5) );      
    % - Initial runs of real data
    % - random starts for all kinds of simulations
    % - BS tasks if random start is specified 
% Generate (possibly another) random start
  seed1=seed1+100; setrand 1, uniform, seed1;
  AA[0,0] = Urandom{0.01, 2.0, 1};  %{lowlim, highlim, # of generator}
  ar=Arrsum{COLUMNAVG[0]};  % ar = sum(COLUMNAVG) = average XX row sum
  
  if> (acbmodel);      % Scale initial average  BB[j2,jp] 
    bs=2.0*bnorm/ar;   % to bnorm*COLUMNAVG[j2]/sum(COLUMNAVG) so  
                       % that initial BB column sums equal bnorm and 
    cs=ar/(bnorm*np);  %.. average BB[j2,jp]*CC[1,jp] = COLUMNAVG[j2] / np 
  else;
    bs=2.0/np;         % average BB[j2,jp] = COLUMNAVG[j2] / np 
    cs=1.0;
  if!;
  for> j2=1:1:n2;
    BB[j2,0] = bs * Urandom{0.0, COLUMNAVG[j2], 1};
  for!;
  CC[0,0] = cs;        % OK both for A*B and A*C*B models
  
elseif (contrun==1 & simu==0 & taskxcount==1); 
   % Continuation run of real data, task # 1. 
   % Both for numtasks==1 and also for numtasks>1.
   % Read previous factor values from file 39 for continuation
    for> ii=1:1:numoldsol;      % Bypass unneeded solutions
      read 39, ' ', AA[0,0], BB[0,0], CC[0,0];
      if> (numpf>0.5);
        read 39, ' ', PF[0,0,0], CM[0,0];
      if!;
    for!;
    closefile 39;
    if> (acbmodel==0);  % For the situation where A*C*B data is used as
      CC[0,0]=1.0;      % starting point for a A*B run, it is necessary 
    if!;                % to reset CC to 1.0.

elseif (contrun==1 & simu==0 & taskxcount>1.5 & errestmode>-0.5);  % ???
     % Real-data BS replication when random start is not requested
     % Possibly also real-data cont. runs with other multiple tasks???
    FREEFACTS[0]=BESTFACTS[0];  % Use best-fit values as default for

elseif (contrun==1 & simu==0 & taskxcount>1.5 & errestmode<-1.5);  % ???
     % Real-data DISP (not BS-DISP) displacement tasks. Do nothing because
     % postproc has already loaded best-fit values if/when they are needed

elseif ( simu==1 | (taskxcount==1 & simu>1.5 & errestmode~=0) ); 
   FREEFACTS[0]=TRUEFACTS[0];  % May be redundant setting for some combinations
   
elseif (taskxcount>1.5 & simu>1.5); 
  if> (errestmode>0.5 & bsinitfact==2 & simu==3);  
    % BS replication runs of simulated data, true start requested. 
    % BESTFACTS exists because (simu==3, task1) computed them. 
    % bsinitfact=1 was already obeyed.              
    FREEFACTS[0]=BESTFACTS[0];
  elseif (errestmode>0.5);     % BS bsinitfact 0 & 3 come here, among others
    FREEFACTS[0]=TRUEFACTS[0];  % True factors are default for simulation 
  if!;                          %.. runs, best-fit and BS computations
    % Do nothing here for errestmode<-1.5 of simulations because postproc has
    % already loaded correct values
else;   
  write 6, '(/I6)', contrun, simu;
  % This is an unplanned stop: must not delete File 14 = iniparams.txt
  stop 'Illegal combination of contrun & simu & possibly other params';
if!;  % End of generating initial values for free factor elements


% Preprocessing: Prepare A normalization weights -- all cases
% -----------------------------------------------------------

if> (bsphase==1);   % BS, not on 1st task
  if> (samplevari==2); 
    for> jp=1:1:np; 
      BSNORMADJ[2,jp]=BSNORMADJ[1,jp]/Bdotprod{BSWEIGHTS[0,1],BESTAA[0,jp]}; 
    for!;
  else;   BSNORMADJ[2,0]=1.0;
  if!;   % Write BSNORMADJ to file 52 later, after writing BS resample counts
if!;     %.. and also copy BSNORMADJ to the cumulative table
    
bs=Arrsum{BSWEIGHTS[0,1]}/n1;        % bs = average value of BS weights
   
% These conditional statements are the only place where ANORMWG are set.   
% if>    ( (bsphase==-1 | bsphase==1) & samplevari==2);  % PMF_bs_6c3

if> (   (bsphase==-1 & samplevari==2)                    % Disp phase of BS_DISP
      | (bsphase==1 & samplevari==2 & bsinitfact>1.5 )   % BS phase of BS_DISP, with 
    );                                                   %.. non-random starts
  for> j1=1:1:n1;       % if bsphase==-1: BSNORMADJ have been read from 53
    for> jp=1:1:np;     % earlier, after reading the counts
      ANORMWG[j1,jp]=BSNORMADJ[2,jp]*BSWEIGHTS[j1,1]/bs;
    for!;
  for!; 
% elseif ( (bsphase==-1 | bsphase==1) & samplevari==1);  % PMF_bs_6c3
elseif (   (bsphase==-1 & samplevari==1)  % Disp phase of BS_DISP without norm adjustments
         | (bsphase==1  & samplevari>0.5)  % BS with original weights or BS phase of BS_DISP,
       );                           %.. where norm adjustments are not wanted or not possible
     % For BS and best-fit of BS-DISP, select BS-weighted A normalization,
     % needed when original sample drawn from "large" population
  for> j1=1:1:n1;             
    ANORMWG[j1,0]=BSWEIGHTS[j1,1]/bs;  % Normalize weight to average=1 
  for!; 
elseif (bsphase==-1 | bsphase==0 | bsphase==1);  
                    % Do not touch ANORMWG if bsphase==2 or <=-2 !
  ANORMWG[0,0]=1.0;  % Set equal AA weights for non-BS and also for
     % BS and best-fit-BS-DISP when no sampling variation is present
     % in the data. Requires reweighting, not resampling, so that all 
     % rows are present in the replication, i.e. must be bsmode > 12.5
if!;    
   
                   

% Prepare initial values for user-specified B pulls -- 1st task only
% ------------------------------------------------------------------
% Negative values in FPULLS.aux3 are indicators for B factor #.
% Replace them by 0.01*(XX col average), to be used as expected change
% cf. reading commands earlier in the script.
if> (taskcount==1);
  for> fp=1:1:numFpull;
    x3=FPULLS.aux3[fp];   % aux3 should be expected change in em = -20..-22
    if> (x3<-0.6);        % aux3<0 is an indicator (= - XX column number)
      FPULLS.aux3[fp]=0.01*COLUMNAVG[-x3]; 
    if!;
  for!;
if!;

% Preprocessing: Initialize FPEAKPULL to go with initial AA values
%-----------------------------------------------------------------
% See comments at similar instructions in callback
% In principle, for BS, the unsampled components of A should be
% excluded from the following computations. It is OK in callback
% where all unsampled AA are =0. Here it is not OK but the only (?)
% harm is a large Qaux at first iterations
%if> (dofpeak>0.01); 
%   Mmtxm{AATAA,AA,AA};             % AA'AA 
%   Mminv{AATAA,AATAA,0.0,0.005};   % inv(AA'AA) (regularized)
%   Mmxm{AATAA,AATAA,FPEAK};        % AATAA = inv(AA'AA)*FPEAK
%   Mmxm{FPEAKPULL,AA,AATAA};   
%   Blincomb{FPEAKPULL[0,0],150.0,FPEAKPULL[0,0],1.0,AA[0,0]};
%if!;           % FPEAKPULL = AA + 150 * AA * inv(AA'*AA) * FPEAK

if> (dofpeak>0.01); 
   Mmtxm{AATAA,AA,AA,BSWEIGHTS[0,2],2};    % AA'AA, weighted 
   Mminv{AATAA,AATAA,0.0,0.005};   % inv(AA'AA) (regularized)
   Mmxm{AATAA,AATAA,FPEAK};        % AATAA = inv(AA'AA)*FPEAK
   Mmxm{FPEAKPULL,AA,AATAA}; 
   Mrowscale{FPEAKPULL,FPEAKPULL,BSWEIGHTS[0,2],2};
   Blincomb{FPEAKPULL[0,0],150.0,FPEAKPULL[0,0],1.0,AA[0,0]};
if!;           % FPEAKPULL = AA + 150 * AA * inv(AA'*AA) * FPEAK




% Save the original array XX if bsmode==14 is going to change it
% --------------------------------------------------------------
if> (bsmode==14 & taskxcount<1.5); 
  XXSAVE[0,0]=XX[0,0];
if!;

% If real data, DISP and BS-DISP: 
% Save the full-data initial matrix BB if errestmode<-1.5
% -------------------------------------------------------
if> (simu==0 & taskcount<1.5 & bsinitfact==1 & errestmode<-1.5); 
  TRUEBBCC[0,0]=BBCC[0,0];    % Fake TRUEBBCC is = initial values
  TRUEAA[0,0]=AA[0,0];
  ##s=' Initial full-data factors';
if!;

% Load the original or modified XX.C1 and XX.C3 values .. reweight?
% -----------------------------------------------------------------
% (may be updated by callback)
XX.C1[0,0]=XXC1[0,0,2];  % load page 2, may contain BS reweighting
XX.C3[0,0]=XXC3[0,0,2];  %.. if this is a BS or BS-DISP resampling run
  
if> (numrowtyps>1.5 & contrun==0);    % Apply reweighting for better startup
  ROWDOWNWG[0]=1.0;      %default
  for> j1=1:1:n1; 
    rc=ROWCODES[j1];
    if> (rc>1.5);             % row type=1 is used as is
      ROWDOWNWG[j1]=2*rc+1;   % row type=2 downweighted by 5
    if!;                      % row type=3 downweighted by 7
  for!;                            
  for> j2=1:1:n2;        % Use ROWDOWNWG for reweighting C1 and C3
    Bproduct{XX.C1[0,j2],ROWDOWNWG[0],XXC1[0,j2,2]};
    Bproduct{XX.C3[0,j2],ROWDOWNWG[0],XXC3[0,j2,2]};
  for!;
if!;

if> (aeruse==1);
  AERPENE[0,0,0]=1.0;   
  % Initial value, will remain for unused elements that remain locked                       
if!;

statuscnt=0; stopcnt=0;   % For callback operations

section!;  %%%%%%%%%%%%%%  End of section "preproc" %%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section> postproc;

write 40, '(///A)',  '  Results written by postprocessing for task #';
write 40, '(I8)', taskcount;
write 40, '(A/)',    '    ----------------------------';

% This section contains different operations:
% 1. Store the results from the present task, to be written later
%    in the form of a summary over many tasks
% 2. Write the results from the present task into different output
%    files.
% 3. (only if it is the last task of a BS sequence or DISP sequence)
%    Write summary information, covering results from all tasks
% 4. Reporting information is written for the GUI to use.

##9='(//(', np,'(I2)', 'E14.5))';   % ##9 = '(//( 5E14.5))' if np=5
% This Format string in ##9 writes np values per line in 5-digit precision 
##a='(//(', np,'(I2)', 'F10.2))';  
%  Format string in ##a writes np values/line in format F10.2
##c='(//(', np,'(I2)', 'F10.5))';  
%  Format string in ##c writes np values/line in format F10.5


if> (gui<0.5 & simu>0);    % Formats for writing simulation results
  ##1='(20(F9.5,1X))';     %.. where very small or very large values
  ##2='(F9.5,1X)';         %.. may not occur
  ##3='(300(1X,F8.4,:))';  % 
  ##5='(1X,F7.3,1X)';  
  ##6='(A9,2X)';          
else;                     % Formats for writing real-world results
  ##1='(20(E15.6,1X))';   %.. where very small and very large values
  ##2='(E15.6,1X)';       %.. may well occur
  ##3='(300(1X,E13.4,:))'; 
  ##5='(1X,E12.3,1X)'; 
  ##6='(A11,5X)';
if!;
##4='(300(1X,F8.3,:))';       % Format for writing scaled residuals and AA
                              % (Also for parametric factors, if used)
                            
                       % Postprocessing:
dispgracut=0;          % Reset here for simplicity. Any task that will need
                       % it should initialize it anew.
                          
if> (taskcount==1 & errestmode>0);     % Save column sums of full-data best-fit AA
  for> jp=1:1:np;                      % Will be used
    BSNORMADJ[1,jp]=Arrsum{AA[0,jp]};  %.. for BS invariant scaling, with samplevari==2
  for!;
if!;

if> (taskxcount==1);
  if> (errestmode~=0);             % Any form of error estimation will be done
    if> (acbmodel==1);             % Safeguard against CC elements 
      rr=0.1*Arrminval{CC[0,0]};   %.. becoming exactly zero in error
      CC.flow[0,0]=rr;             %.. estimation tasks
    if!;                                
    for> jj=1:1:numfreef;             % compute best-possible error estimates
      fk=FREEFACTS.fkey[jj];          %.. corresponding to other factors being constant
      if> (fk==locked | fk==masked);  % If this factor is not fitted at all,
        HINVDIAG[jj]=99.99;           % consider its precision non-existent
      else;
        HINVDIAG[jj]=1.0/Sqrt{FREEFACTS.fhdiag[jj]+0.000000000001};
           % Protect against 0   (Otherwise, a zero
           %.. would occur if no information exists for a variable) 
      if!;
    for!;
    for> jp=1:1:np;         % Provide single-variable uncertainty for BB/CC elements
      for> j2=1:1:n2;       %.. initially to be used for DISP displacements
        rw=BB.fhdiag[j2,jp];
        if>  (BB.fkey[j2,jp]==locked | BB.fkey[j2,jp]==masked);  
                          HINVDIABC[j2,jp]=bnorm;
        elseif(rw==0.0);  HINVDIABC[j2,jp]=bnorm;  % ????? Not clear what to inserted here
        else;             HINVDIABC[j2,jp]=1.0/Sqrt{rw};
        if!;
      for!;
      HINVDIABC[n2+1,jp]=1.0/Sqrt{CC.fhdiag[1,jp]};
    for!;
    
    if> (errestmode<-1.5);       % Here, taskxcount==1,  DISP or BD-DISP
      BESTBBCC[0,0]=BBCC[0,0];   % Store (resampled) best-fit BBCC
      numconsfac=0;
      for> ff=1:1:numabfact;     % Count # of approx. lowlim-constrained best factors
        if> (  FREEFACTS[ff]<FREEFACTS.flow[ff]+0.01*HINVDIAG[ff] & 
               (FREEFACTS.fkey[ff]==lolimit | FREEFACTS.fkey[ff]==lohilimits) );
          numconsfac=numconsfac+1;
        if!;
      for!;
    if!;
  if!;  
%  if> (simu==0 &( doresort~=0 | (errestmode<-1.5 & bsinitfact==0)  ));  
if!;   % closing if> for taskxcount==1 and >1

if> ( simu==0 & taskcount<1.5 & (bsinitfact~=1 | errestmode>-1.5) ); 
  % Save first unsorted BB & CC results as "TRUEBB" and "TRUECC" 
  % in non-simu runs, except for (BS-)DISP with bsinitfact==1. Saved values will 
  % be used as correlation reference and for re-sorting factors in all tasks,
  % and in output and comparisons in non-simu (BS-)DISP runs if bsinitfact==0.
  TRUEBBCC[0,0]=BBCC[0,0];    % Fake TRUEBBCC is = 1st full-data best-fit values
  TRUEAA[0,0]=AA[0,0];        %.. will be used also when analyzing
  ##s=' Best-fit factors';    %.. resample best-fit results
if!;



% Postprocessing:
% Conditionally, re-sort computed factors so that computed BB columns 
% become maximally correlated with TRUEBB columns, or
% alternatively, AA columns become maximally correlated with TRUEAA. 
% Re-sorts all factor matrices (AA,BB,CC,PF,CM) both after full-data 
% and BS simulation computations. For BS, needed because of random 
% starts!  --  AA sorting selected if    sortAcorr==1
%------------------------------------------------------------------
% Compute uncentered "correlations" of computed A/B columns vs. 
% TRUEAA/TRUEBB columns. 
% First (row) index jp of CORREL points to computed BB
% Second (column) index jq of CORREL points to TRUEBB

if> (numpf>0.5);                  % copy .sres values for swapping and
  AAMSRES[0,0]=AAM.sres[0,0];     %.. output (.sres itself is read-only) 
if!;
if> (aeruse==1);
  AERCONSRES[0,0]=AERCONS.sres[0,0];  % copy .sres values, as above 
if!;
if> (dofpeak>0.01);          % copy .sres values for swapping and output 
  FPEAKSRES[0,0]=FPEAKPULL.sres[0,0]; 
if!;

didsort=0;
if> (doresort~=0);  % Compute correlations. if =+1, re-sort.
  if> (sortAcorr==1);
    Mxcorrel{CORREL,AA,TRUEAA,BSWEIGHTS[0,2],2};
  else;
    Mxcorrel{CORREL,BB,TRUEBB,COLUMNAVG[0],-2};
  if!; 
  
%  write 40, '(/A)',  '  Raw correlation matrix before sorting';
%  callsubr Fwrite2{40, '(30(1X,F6.3,:))', '(1X)'}{CORREL};  
  
    % Set correlations to 0.0 between factors of different types
  Bproduct{CORREL[0,0], CORREL[0,0], FSAMETYPE[0,0]};
  
    % Now, if doresort==1, and not 2nd phase of BS,
    % swap columns (of BB and of all other factors) so that 
    % highest correlation is moved to diagonal of CORREL.
    % Also move the replaced row in CORREL.
    % If doresort==-1, simply copy diagonals of CORREL to CORRTABLE
  CORRTABLE[taskcount,0]=-1;      
  if> (doresort>0.5 & bsphase<1.5);
    didsort=-1;      % sorting was enabled but not yet used
    % All elements of CORRTABLE row should be set in the loop
    for> jt=1:1:np;  % for each factor, search for the largest elem
                     % in matrix CORREL
      mx=-2; jx=0; jq=0;             % Accept all values -1.00 to +1.00 
      for> jp=1:1:np;                % Scan all columns for array max value 
        rr=Arrmaxval{CORREL[0,jp]};  % Find largest in column jp
        if> (rr>mx); 
          mx=rr; jq=jp;
          jx=Arrmaxloc{CORREL[0,jq]};  % so far, max value in (jx,jq)
        if!;
      for!;
      CORRTABLE[taskcount,jq]=CORREL[jx,jq];      % Save for writing
      % element (jx,jq) will be (logically) swapped to (jq,jq)
      if> (jx~=jq);                  % swap factors jx and jq
        didsort=1;       % Indicate that factors have been re-sorted          
        for> i1=0:np:numfreef-np;   % last value of i1 is numfreef-np
          rr=FREEFACTS[i1+jx]; FREEFACTS[i1+jx]=FREEFACTS[i1+jq];
          FREEFACTS[i1+jq]=rr;
        for!;
        if> (numpf>0.5);    Bswap{AAMSRES[0,jx],  AAMSRES[0,jq]};
        if!;
        if> (dofpeak>0.01); Bswap{FPEAKSRES[0,jx],FPEAKSRES[0,jq]};
        if!;
        if> (aeruse==1);
          Bswap{AERCONSRES[0,jx],AERCONSRES[0,jq]};
        if!;
        CORREL[jx,0]=CORREL[jq,0];  % Copy unused row jq away to jx
      if!;                          % (no need to copy the used row jx)
      CORREL[jq,0]=-3;   % Make row and column of the new diagonal jq,jq 
      CORREL[0,jq]=-3;   %.. "invisible" in new searches 
    for!;  
  else;                % End of re-sorting computed factors (doresort>0)
    for> jp=1:1:np;    % Save computed correlations without sorting because
      CORRTABLE[taskcount,jp]=CORREL[jp,jp];   %.. doresort<0 or 2nd BS task
    for!;   
  if!; 
if!;    % End of computing correlations and possibly re-sorting factors


if> ( bsphase==1 & samplevari==2 & bsinitfact==1 );
    % This is BS with random starts and suppressed sampling variation:
    % BSNORMADJ have been computed but not applied to factors.
    % For debugging, apply now to BB factors in order to be able
    % to compare BS output table with corresponding BS-DISP table  
  for> jp=1:1:np; 
    Blincomb{BB[0,jp], BSNORMADJ[2,jp], BB[0,jp]};       % multiply BB column
    Blincomb{AA[0,jp], 1.0/BSNORMADJ[2,jp], AA[0,jp]};   % divide   AA column
  for!;
if!;

if> (bsmode==14);         % If modifying residuals instead of resampling, 
  if> (bsphase==0);       %.. prepare best-fit info
    Blincomb{BESTFIT[0,0],  1.0, XXSAVE[0,0],  -1.0, XX.res[0,0]};
      % After 1st task: Save best fit, compute BESTFIT = XXSAVE - XX.res
  elseif (bsphase==2);    % After the second BS task of each pair:
    XX[0,0]=XXSAVE[0,0];  % Restore original XX. It is modified by BS-on-residuals 
  if!;                    %.. when bsmode=14 is used.
if!;   % Restoring XX is probably not needed. Doing it for just in case ...  

if> (taskxcount==1 & bsphase>-3.5 | bsphase==1);
  % Computing weighted pseudoinverse AAFSTPINV of reference AA ("AATRUE")  
  % BS, unpulled case: use current resampling for weights
  % DISP: compute only once, in first task
  % BSDISP: compute again for each new resample, unless there are errors
  % OTHER: compute in first task only
  Mmtxm{AATAA,TRUEAA,TRUEAA,BSWEIGHTS[0,2],2};   %
  Mminv{AATAA,AATAA,0.0,0.005};    % parameters: {inv, matr, tol, reg}
  Mmxm{AAFSTPINV,AA,AATAA};        % AAFSTPINV is transposed pseudoinverse of first AA
                                   % with current weighting
  Mrowscale{AAFSTPINV,AAFSTPINV,BSWEIGHTS[0,2],2};
if!;


% Write computed (possibly resorted) factors in simple form, 
% for reading by the GUI or by a future continuation run: 
% ---------------------------------------------------------
% Set the writing limit pr as needed. Default for BS runs is pr=5.
pr=numtasks;
if> (errestmode<-1.5); pr=5;   % Less output for DISP and BS-DISP runs
if!;
if> (taskxcount<=pr & taskcount<=numtasks);  
  % Only write pr first results to .dat file. Do not write if "stop" has ..
  write 49, ##9, AA[0,0], BB[0,0], CC[0,0];    %.. cancelled this task
  if> (numpf>0.5);
    write 49, ##9, PF[0,0,0],   % Write parametric factors
       CM[0,0];                 %.. and source strength coefficients
  if!;                          %.. of the parametric model
if!;
QTABLE[taskcount,1]=mainqvalue;
QTABLE[taskcount,2]=auxqvalue;


% Postprocessing: Write BS results to file 52 for BS-DISP
% -------------------------------------------------------
if> (errestmode>1.5);          % Only for errestmode=2
  if> (taskcount>1.5);         % Do not write -- for full-data fit --
    write 52, '(//(20F6.2))', BSCOUNTS[0];   %.. neither the counts nor the
    write 52, '(//30F8.3)', BSNORMADJ[2,0];  %.. adjustments to file 52 
    BSNORMADJ[taskcount+2,0]=BSNORMADJ[2,0];
  if!;
  write 52, ##9, FREEFACTS[0];  % Write all factors, also unused ones
  if> (taskcount>=numtasks);    % Last BS task: Write table of norm coefficients ..
    fi=49;                      % adjust file number fi to other than 49 if needed
    write fi, '(//)';           %.. as a table of numtasks-1 rows
    for> tc=4:1:numtasks+2;
      write fi, '(/30F8.3)', BSNORMADJ[tc,0];  % No writing for task # 1
    for!;
  if!;
if!;


% Postprocessing:
% Update the report file 17, so that GUI can display the info for the user 
% ------------------------------------------------------------------------
% Re-open the report file, except for the first task.

if> (taskcount==1); 
  openfile  17,    ##r,     W,  'replace',     200;
  if> (gui<0.5);  % omit titles in GUI runs, so that file is easier to read
    write 17, '(A/)',  
    '/ task#, iter#, Q, Qm, Qa, Qmtrue, gradnorm, #posoutl, #negoutl, endcode'; 
  if!;
  closefile 17;
if!;
% Try repeatedly to re-open the file, in case GUI is holding the file temporarily
ee=1;
while> (ee~=0); 
    openfile  17,  ##r,  W,  'unknown',  200, ee;
    if> (ee~=0); sleep 1;   % Wait one second if file could not be opened
    if!;
while!;
write 17, '(I5)', taskcount, itercount;
write 17, '(E15.6)', qvalue, mainqvalue, auxqvalue, trueqvalue, gradnorm;
write 17, '(1X,I4)', numposoutl, numnegoutl, endingnow;
closefile 17;
% ---------------------------------------------------------------------- 

 
 
% Postprocessing:
% Work with the BS results table RESLT (not writing RESLT yet) 
% Initial settings of RESLT, Insert results in RESLT
% ---------------------------------------------------
if> (dotable>0.5);            % BS or simulations with different noise. Not DISP.
  if> (taskxcount==1);        % Best-fit was computed as 1. task of BS runs 
    if> (errestmode>0.5);  BESTFACTS[0]=FREEFACTS[0]; 
    else; BESTFACTS[0]=0;     % Simu=2: no BESTFACTS exist
    if!;    % Store computed AA, BB, and CC factors in BESTFACTS. 
            % These two, above, and initialization of DISP pulling
            % (below) are the only three places where BESTFACTS is set. 
    RESLT[0,0,0]=-99950;        % Invalid values, marker for locations
    for> jj=1:1:numfreef;        %.. that do not receive any value at all
      rr=FREEFACTS[jj];          % Store best-fit AA BB CC PF CM in
      RESLT[jj,taskxcount,0]=rr;  %.. first row of RESLT (in both pages)
    for!;                         %.. to be equal to best-fit values
    
% No need to initialize MINMAXFACT because it is filled using Bsort{}    
%    for> kk=1:1:numextrem;
%      MINMAXFACT[0,kk,0]= 100000000; 
%    for!;            % "plus Inf" initialization of CI left ends
%    for> kk=numextrem+1:1:2*numextrem;
%      MINMAXFACT[0,kk,0]=-100000000; 
%    for!;            % "minus Inf" initialization of CI right ends
    
  elseif (taskcount<=numtasks);  % taskcount>1
       % Avoid situation when taskcount=numtasks+1, i.e. when the
       % "stop" operation in callback has cancelled the interrupted
       % task by setting numtasks=taskcount-1.  
       % Doing tasks #>1, i.e. noise-added or pulled-sampled cases.
       % For simu=2, pulling-based tests indicate not-pulled for all 
       % factors, hence special treatment is not needed for simu=2. 
    for> jj=1:1:n1*np;                     % look through AA
      j1=Integerdiv{jj+np-1, np};          % j1=1, 2,...,n1
        %  Unused RSLT values have already been marked wholesale
  %    RESLT[jj,taskxcount,0]=-99900;   % No need to mark again
        % This value is a marker for the unused values in the "wrong" plane
        % It will remain in the "wrong" plane.
      if> (ROWPULLIND[j1]==0);             % Do for sampled non-pulled rows
        RESLT[jj,taskxcount,splitBScod]=FREEFACTS[jj];  % non-pulled: store computed value
  %    else;                                     % pulled or not sampled: store marker
  %      RESLT[jj,taskxcount,splitBScod]=-99900;  %.. indicating invalid value 
             % This insertion was intended for highlighting pulled or not-sampled
             % values so that those may be replaced by best-fit values 
             % when writing the table. This is a questionable idea, probably
             % something else should be done.
      if!;
    for!;
    for> jj=n1*np+1:1:numfreef;   % Loop through BB, CC, PF, CM,
  %    RESLT[jj,taskxcount,0]=-99900;    % mark unused columns of RESLT
        % There is nothing to screen for. Store computed value
      RESLT[jj,taskxcount,splitBScod]=FREEFACTS[jj];  
    for!;
 %   callsubr Minmaxsetx{}{};          % Update CI's = elements of MINMAXFACT 
 %   The new sort-based Minmaxsetx is called in last task, for all resamples
  if!;  
if!;  
% Results table RESLT has been updated (dotable>0.5)
% ------------------------------------  


% Postprocessing:
% Output of diagnostic information (Q values etc) and control parameters
% ----------------------------------------------------------------------
qxx=Arrsumosqr{XX.sres[0,0]};
QTABLE[taskcount,3]=qxx;
QMCONTRIB[0]=0.0;
if> (numrowtyps>1);  % Compute Qmain contributions from row types
  for> j1=1:1:n1;
    rc=ROWCODES[j1];
    if> (rc>0);  QMCONTRIB[rc]=QMCONTRIB[rc]+Arrsumosqr{XX.sres[j1,0]};
    if!;
  for!;
if!;
for> fi={40,24};           % Write to main output file 40 and to log file 24
  write fi, '(//A/)',      % -----------------------------------------------
  '  task#,  Q(robust),  Qmain,  Qaux,  Q(True),  Q(Anorm),  Q(Bnorm),  Q(XX)';
  write fi, '(I5)',  taskcount;
  write fi, '(E15.6)', qvalue, mainqvalue, auxqvalue, trueqvalue;
  write fi, '(F10.3)', Arrsumosqr{NORMS.sres[1,0]}, Arrsumosqr{NORMS.sres[2,0]}; 
  write fi, '(E15.6)', qxx;
  if> (numrowtyps>1); 
    write fi, '(/A)', '  Qmain(True) contributions from row types 1, 2, ... =';
    write fi, '(10F10.1)', QMCONTRIB[0];
  if!;
  if> (didsort>0.5); 
    write fi, '(//A)',  '  Re-sorted factors for max. similarity with'; 
    write fi, '(A/)',   ##s;
  if!;
  if> (errestmode<-2.5);
    if> (dispbsnumb==1);
      write fi, '(//A/)',  '  BS-DISP: processing full-data case, a.k.a. resample # 0';
    else;
      write fi, '(//A)',  '  BS-DISP: processing resample #';
      write fi, '(I7/)',  dispbsnumb-1;
    if!;
  if!;
  if> (dofpeak>0.01);
    if> (didsort>0.5 & dofpeak>1.5);  write fi, '(A/)',  
       '  *** FPEAK table does not correspond to shown order of factors! ***'; 
    if!;
    write fi, '(//A/)',  '   Q contribution from FPEAK pulling of individual factors:'; 
    for> jp=1:1:np;   write fi, '(1X,F7.1)', Arrsumosqr{FPEAKSRES[0,jp]};
    for!;    
  if!;
  if> ( taskxcount==2 & errestmode==-2);  % Error estimation by BB displacing
      write fi, '(//A)', '  dQmax values for DISP error estimation';
      write fi, '(10F7.1)', DISPDQMAX[0];
  if!;
  
  if> (usemorepar>0);
     write fi, '(//A/)', '  Control info from "moreparams.txt" is in use:';
     write fi, '(I6)', numGpull, numFpull, readGcontr, readFcontr;
  if!;
 
  if> (aeruse==1);
    write fi, '(//A/)',  '  Factor specific Qaux contributions from the AER model';
    for> jp=1:1:np;  write fi, '(1X,F7.1)', Arrsumosqr{AERCONSRES[0,jp]};
    for!;  write fi, '(/)';
  if!;
  
  if> (numpf>0);
    write fi, '(//A)',  '  Q values from the parametric model';
    write fi, '(/A/)',  '   Q(AAM),  Q(PFpull), Q(PFsmoo), Q(PFnorm)';
    write fi, '(F10.4)', 
      Arrsumosqr{AAMSRES[0,0]}, Arrsumosqr{PFPULL.sres[0,0,0]},
      Arrsumosqr{PFSMOO.sres[0,0,0]}, Arrsumosqr{PFNORM.sres[0,0]};
    write fi, '(/A/)',  '   Q(AAM) contributions from individual factors';
    for> jp=1:1:np;
      write fi, '(1X,F7.1)', Arrsumosqr{AAMSRES[0,jp]};
    for!;
  if!;
  
  if> (doresort~=0);
    write fi, '(//2X)';
    if> (sortAcorr==1);
      write fi, '(A)', 'Source contributions: G "correlations" with', ##s;
    else;
      write fi, '(A)', 'Source profiles: F "correlations" with', ##s;
    if!;
    write fi, '(/)';
    write fi, '(30(1X,F7.3,:))', CORRTABLE[taskcount,0];
  if!;
for!;

Mxcorrel{CORREL,BB,TRUEBB,COLUMNAVG[0],-2};
Mxcorrel{CORREL2,AA,TRUEAA,BSWEIGHTS[0,2],2};

if> (didsort==0);    write 40, '(//A)', '  Factor sorting not enabled now';
elseif(didsort<-0.5);   write 40, '(///A)',
    '  Factor sorting was enabled but not needed now';
else;
  if> (sortAcorr==1);  write 40, '(//A)',
    '  Factor sorting was performed, based on G factors';
  else;                write 40, '(//A)',
    '  Factor sorting was performed, based on F factors';
  if!;
  write 40, '(/A)', '  Sorted factors used for all output of this task';
if!;

  write 40, '(//A/)',
    '  Uncentered "cross correlations" of fitted factors (rows)';
  write 40, '(A)',    '  vs.',  ##s,  ' (columns)';
  write 40, '(/A)',   '  Correlations of weighted F factors:';
  callsubr Fwrite2{40, '(30(1X,F6.3,:))', '(1X)'}{CORREL};  
  write 40, '(/A)',  '  Correlations of G factors:';
  callsubr Fwrite2{40, '(30(1X,F6.3,:))', '(1X)'}{CORREL2};  


% Postprocessing: both DISP and BS-DISP
% Initiate, open files. Collect what was computed in this task, then 
% prepare for next task or prepare for ending the run.
% ---------------------------------------------------------------------
if> (errestmode>0.5 & taskcount==1); 
  for> dl=1:1:dispdqlevs;
    DISPDQHEAD[dl,1]='Extreme', dispdqlevs-dl+1, '(I2)'; 
  for!;                      % for identifying the most extreme BS values
if!;
if> (errestmode<-1.5 & taskcount==1);   % One-time preparations for dQ-displacing 
  if> (errestmode<-2.5); ##f='BSDISPres';  % for BS-DISP
  else;                  ##f='DISPres';    % for DISP
  if!;
  for> dl=1:1:dispdqlevs;
    DISPDQHEAD[dl,1]='dQmax=', DISPDQMAX[dl], '(F5.1)'; 
    DISPDQHEAD[dl,2]=##f, dl, '(I1)', '.txt';
    openfile 80+dl, DISPDQHEAD[dl,2], W, 'replace', 20000;
  for!;        % for displaying dQmax values: e.g. "dQmax= 20.0" or "dQmax= 20"
  for> jp=1:1:np;
    DISPBC1STP[n2+1,jp,3]=0.001*Arrsum{BBCC[n2+1,0]}+HINVDIABC[n2+1,jp];
    for> j2=1:1:n2; 
      DISPBC1STP[j2,jp,3]=0.002*Arrsum{BBCC[j2,0]}+HINVDIABC[j2,jp];
    for!;   
  for!;  % DISPBC1STP[0,0,3] are "tolerances" for stepping.
if!;



% Compute the regression of current AA  ------- all tasks, also BS, (BS-)DISP *****
%.. on 1st AA (for DISP, and for random starts),   or
%.. on AA computed by preceding bsphase=1 (used only for BS when bsphase=2)
%.. on AA computed by preceding bsphase=-1 (for BS-DISP)
% Weighting might be applied here but it is not necessary because
% in BS and in BS-DISP, unsampled AA rows are already =0.

Mmtxm{CORREL,AAFSTPINV,AA};  
  % CORREL = Coefficients for approximating current AA by the "first" AA

if> (errestmode~=0);     % Do not check for ordinary random starts etc.
  callsubr Diagcheck{smalldiag,dispswap1,dispswap2}{CORREL,SMALLDIA}; 
   % 2009-05-09: 0.5,--  2009-06-16: 0.8,--  2009-06-16: 0.8,0.4
   % 2010-10-30: 0.9,0.5   
  if> (smalldiag>1.5);         % Collect factor-specific swap info for all   
     % computed errest solutions, rejected and accepted.
     % This may help the user analyze the PMF model: which factors are reliable 
     % and which are not. Output at end of run.     --------     2009-06-17
    for> jp=1:1:np; SMALLDIA[2,jp]=SMALLDIA[2,jp]+SMALLDIA[1,jp]; 
    for!;  
    SMALLDIA[3,0]=SMALLDIA[1,0];       % Save last swap indicators for summary purposes
                                       %.. will only be reset in Dispnext
    if> (errestmode<-2.5 & taskxcount==1 & taskcount>1);   % BS-DISP resample best fit bad?  
      write 40, '(//A)',  '  BS-DISP best fit has factor swaps for resample #';
      write 40, '(I8)',  dispbsnumb-1;
      DISPREJCNT[2]=DISPREJCNT[2]+1;
      for> dl=1:1:dispdqlevs;           % Mark swaps in factor swap table
        Blincomb{SMALLDIA[dl+3,0], 1.0,SMALLDIA[dl+3,0], 1.0,SMALLDIA[1,0]};
      for!;
      disprejsco=Maxval{disprejsco,2};
      if> (disprejthr<1.5);   % If disprejthr=1, abort processing of resample at once
        bsphase=-4;           % Do not even try calling Dispnext{}
      if!;
    if!;
  if!;                               
else;  smalldiag=0;
if!;

if> (bsphase==2);              % Output regression table in BS
  write 40, '(//A)',  '  For this BS resample: rotationally pulled G1 ~ unpulled G0 * T1';
  write 40, '(/A)',   '  Column k of T1 contains coefficients for column k of matrix G1:';
  callsubr Fwrite2{40, '(30(1X,F6.3,:))', '(1X)'}{CORREL};  % CORREL computed some 200 lines back
if!;
if> (simu~=1 & taskcount>1); 
  write 40, '(//A)', '  Regression matrix T1 of fitted G vs. reference G:';
  callsubr Fwrite2{40, '(30(1X,F6.3,:))', '(1X)'}{CORREL}; 
if!;  % Write for all cases, including perturbed BS-DISP, except for varying-data simulations


% Processing results of a DISP best fit or BSDISP best fit, full or resample
%---------------------------------------------------------------------------
if> (errestmode<-1.5 & taskxcount==1 & bsphase>-3.5);  % preparations needed for dQ-displacing 
  DISPBC1STP[0,0,1]=BESTBBCC[0,0];      % Initial status: (resampled) best-fit values of all 
  DISPBC1STP[0,0,2]=BESTBBCC[0,0];      %.. BC elements, both for min and max estimates
  for> dl=1:1:dispdqlevs;
    for> ii=3:1:4;                         % Initialization for this BS-DISP resample by
      DISPBCMIX[0,0,dl,ii]=BESTBBCC[0,0];  %.. using resample-best-fit BBCC values     
    for!;                
  for!;  
  DISPBCMIX[0,0,0,1]=777777.7;   % indicator for not-estimated min estimate (actively)
  DISPBCMIX[0,0,0,2]=-77777.7;   % indicator for not-estimated max estimate (.. displaced)
  DISPBCMIX[0,0,0,5]=dispFscale; % Initialize min estimates using largest possible value
  DISPBCMIX[0,0,0,6]=0;          % Initialize max estimates using smallest possible value
  for> j2=1:1:n2+1;
    for> jp=1:1:np;
      if> (DISPBCMASK[j2,jp]==0);        % this is a masked element
        DISPBCMIX[j2,jp,0,1]=999.999;    % indicator for masked min estimate
        DISPBCMIX[j2,jp,0,2]=-999.999;   % indicator for masked max estimate
      if!;      % If some not-estimated indicators are visible in results it indicates
    for!;       %.. problems in script or in run, such as too few tasks defined.
  for!;  
  if> (acbmodel==0); DISPBCMIX[n2+1,0,0,0]=1.0; 
  if!;     % Post no indicators for unused unestimated CC elements!
  
                                % postprocessing, errestmode==-2 or ==-3, taskxcount=1
  bestmainq=mainqvalue;         % Store Qm of best fit for later comparisons
  BESTFACTS[0]=FREEFACTS[0];    % Store best (resampled) solution for later initializations
                                    % Best solution is needed by Dispnext!  
  BESTGRAD[0,0]=BBCC.fgrad[0,0];    % Gradient at best solution
  if> (errestmode<-2.5); bsphase=-2; 
  if!;                     
  dispstate=-3;               % Initiate Dispnext for displacing up
  callsubr Dispnext{}{};      % Select first BB/CC element to perturb up
  if> (dispstate==-3);
    for> fi={6,24,40};  write fi, '(A/)', 
      '  No F or C matrix elements selected for displacement.',
      '  Ending the run after completing the first task.';
    for!;
    numtasks=1;   % Force ending of run at once
  if!;
if!;   % Initiated DISP or BS-DISP processing (in postproc of first task)
       %.. or initiated BS-DISP processing of one resample, after completing 
       %.. displ. of previous resample  


% Postprocessing: Process results from one DISP or BS-DISP displacement -- not best fit
% -------------------------------------------------------------------------------------
% If smalldiag>1.5 for the best fit, it was already handled, above. It may have set
% bsphase=-4 if BS-DISP.

if> (errestmode<-1.5 & taskxcount>1 & bsphase>-3.5);  % DISP or non-rejected BSDISP    
  DISPLTABLE[di1,6]=smalldiag;           
     % Set (or reset) factor swapping indicator. If this is a successful (non-swap) retry 
     % of an earlier swapped case, smalldiag will be =0 or =1, resetting the indicator
     
  if> (smalldiag>1.5);  DISPLTABLE[1,6]=smalldiag;   % Store last failure code
  if!;                                               %.. for cases where not-reached occurs

  lc=0;  % counts factors that are at lower limit
  for> ff=1:1:numabfact;                                 % Evaluate #-of-zeros correction
    if> (  FREEFACTS[ff]<FREEFACTS.flow[ff]+0.01*HINVDIAG[ff] & 
           (FREEFACTS.fkey[ff]==lolimit | FREEFACTS.fkey[ff]==lohilimits) );
      lc=lc+1;
    if!;
  for!;
  df=(numconsfac-lc);  % df = (# of constrained in best - # of constr. now)
    % if df<0,  i.e. more zeros in perturbed solution,
    % i.e. decrease of # of free parameters
    % --> degrees-of-freedom increases --> non-significant increase of Q is expected
    % --> additive correction to observed dQ value should be negative
  if> (df>0);  DISPLTABLE[di1,7]=df*degfreedom/3.0;  % suppress positive corr. to Q
  else;        DISPLTABLE[di1,7]=df*degfreedom;      % correction decreases Q value
  if!;
  
  DISPLTABLE[di1,4]=BBCC.fgrad[dispj2,dispjp];           % new gradient component, >0 or <0
  deltaq=0.5*(DISPLTABLE[di1,4] + DISPLTABLE[dispind,4]) * (dispnow-dispokmx);   
           % deltaq  = increase of dQ =  average gradient * this displacement step          
  DISPLTABLE[di1,5] = DISPLTABLE[dispind,5]  + deltaq;   % previous dQ (or 0) + deltaq
           % = cumulative deltaq up to this point
  deltagrad=DISPLTABLE[di1,4]-DISPLTABLE[dispind,4];     % = change of gradient
  
  dispdQneg=Minval{dispdQneg,DISPLTABLE[di1,5]};         % Look for largest drop of Q in DISPing
  
  sx=0;          % Classify the obtained result, dispstcode = 1,2,3 (4), 5
                 % Clear obsolete error indicator sx
                 
  if> (DISPLTABLE[di1,5]<-10.0-DISPDQMAX[dispdqlevs]);
    dispstcode=5;                            % causes rejection of DISPing & BS-DISP resample
  elseif ( deltaq>DISPDQMAX[dispdqlevs] |    % Prepare for shortening the step..
        (deltaq>DISPDQMAX[2] & dispdQok<DISPDQMAX[1] & dispHQdone==0)  );
    dispstcode=2;                  %.. because steep rise prevents accurate Q estimations
  elseif (smalldiag>1);
    dispstcode=3;   % Two-or-more-factors appear swapped or very strong rotation
    sx=smalldiag;   % sx indicates failure mode, in case this displacement ends in failure
  else;
    dispstcode=1;   % accepted step
  if!; 
  
           % di1 is always = dispind+1, index of next column in DISPLTABLE
  e1=di1;  % e1 = saved di1 for output operations    % Operations for each step code
  rg=(Abs{dispstep}<dispmindis & dispstpcnt>5);      % rg=.. enables convergence in several cases ??

  if> (dispstcode==1);         % ==1 means accepted step (state transitions at the end of this block)
    dispdQok=DISPLTABLE[di1,5]+DISPLTABLE[di1,7];    % The new accepted largest -corrected- achieved dQ, ..
    ek=dispdQok; 
    nr=-1;            % -1 = "not-reached" status code, assumed until shown otherwise
    if> (outdisp); 
      ek=Maxval{ek,DISPDQMAX[dispdqlevs]+2.0};       %.. or a signal value for outdisp, ..
      nr=smalldiag;              % cancels "not-reached" status code because of outdisp
    if!;
    DISPBCHIQ[dispj2,dispjp,dispud]=ek;              %.. is stored in dQ-statistics-table
     % Identify those dQmax value(s) (if any) that are > dQ(corrected) of previous
     % displacement and  <= dQ(corr.) of this displacement. Compute approximate
     % displacements corresponding to those dQmax values
     % Occasionally, variations in deg-of-freedom may cause that the corrected Q
     % is not monotonous, so that interpolated Q equals the same threshold value dQmax 
     % in two different intervals. The algorithm, below, will detect both occurrences.
     % Data for the last one, with largest displacement, will override the data for the
     % first one. This is probably the desired behavior.  (???)
     % -- In cases where corrected Q first drops and then increases within one interval,
     % and dQmax is between end values, the increase up through dQmax is noted properly.

    d0=(dispnow-dispokmx);      % Current step (= incremental displacement)
                                % This must be the previous dispokmx, not yet updated
    for> dl=1:1:dispdqlevs;
      dispdq1=DISPDQMAX[dl];        % Step through all dQmax levels, see which ones apply
      if> (dispdq1 > dispdQok);     % This dQmax not exceeded: DISPDQMAX is > dQ at far end of displ.
                   % Level number dl has not been reached yet. Fill its confid-interval data with
                   % displacement of the accepted far end.      % If not outdisp, fill CI 
        DISPBCMIX[dispj2,dispjp,dl,dispud]=DISPLTABLE[di1,1];   %.. status code with code = -1                              
        DISPSTATS[dispj2,dispjp,dl,2+dispud]=nr;                %..  = "dQmax not reached" 
        DISPBCINT[0,0,dl]=BBCC[0,0];             % Store current result as "achieved values"
           % if outdisp, this will be final. If not, it will usually change with another displ.
      elseif (dispdq1 > DISPLTABLE[dispind,5]+DISPLTABLE[dispind,7]);
           % dQmax for this level is > dQ(corr,left-end) and <= dQ(corr,right-end)
           % of this displacement: Limit was exceeded!
        dr=0.025; rr=dr;
        while> (rr< 1.01);                   % Step through current displacement in 40 steps
          qq=DISPLTABLE[dispind,5]           % dQ (uncorrected)  at left end of disp
          + (rr*d0)*DISPLTABLE[dispind,4]    % + dQ linear term = (fract-of-step) * left grad.comp. 
          + 0.5*deltagrad*d0*rr*rr;          % + dQ 2.order term, 0.5*deltagrad*step*fraction^2
                                             % qq is now the interpolated uncorrected dQ
                                             
          dispdQneg=Minval{dispdQneg,qq};    % Look for most negative dQ in all computed fits in this run
        
          qq=qq+DISPLTABLE[dispind,7]                           % add correction at left end
           + rr * (DISPLTABLE[di1,7]-DISPLTABLE[dispind,7]);    % add correction linear interpolation
                                 % qq = 2.-degree interpolated corrected dQ at fraction rr of displ
                                 
          if> (dispdq1<=qq);     % qq (interpolated dQ) has now stepped past dispdq1 = dQmax
            DISPBCMIX[dispj2,dispjp,dl,dispud]=BESTBBCC[dispj2,dispjp]+dispokmx+rr*d0;     
                                       % store (resampled) best-fit plus interpolated displacement
            DISPSTATS[dispj2,dispjp,dl,2+dispud]=smalldiag;  % set/reset status code of swap 
            Blincomb{DISPBCINT[0,0,dl], (1.0-rr), PREVOKBBCC[0,0], rr, BBCC[0,0]};
              % Interpolate to DISPBCINT the fictitious solution, corresponding to fractional
              % step rr from solution stored in PREVOKBBCC to current solution BBCC
            rr=2.0;
          else;
            rr=rr+dr;   % step fractionally, by 2.5 % of whole displacement in each step
          if!;
        while!;  % while steps through the displacement with one dQ level
      if!;   
    for!;   % looping through dQ levels
    
    % (BS-)DISP Postprocessing   (errestmode<-1.5 & taskxcount>1 & dispstcode==1)  ------------
    
    % All those dQmax levels (dispdq1) that were not exceeded by the corrected dQ of this 
    % displacement have been filled with the best substitute, in anticipation of the case
    % that no further accepted displacements will be achieved. Status table for those levels 
    % has been marked with status code -1, "displacement falls short", except for outdisp
    % steps. If termination is because of converged dispHQdone, then the status codes
    % will be reset to success = 0.
    
    if> (dispdQok<DISPDQMAX[1]);            % This small_dQ result is universally OK. Use it.
      Bmin{DISPBC1STP[0,0,1],NaN,DISPBC1STP[0,0,1],BBCC[0,0]};  %.. for updating smallest so
      Bmax{DISPBC1STP[0,0,2],NaN,DISPBC1STP[0,0,2],BBCC[0,0]};  %.. far and largest so far
    if!; % saved results for dispstcode=1, still having (errestmode==-2 & taskxcount>1)

    dispokmx=dispnow;            % Store the information that this is the last (best)
    PREVOKBBCC[0,0]=BBCC[0,0];   %.. accepted step when DISPing this BBCC element
    OKDISFACT[0]=FREEFACTS[0];   % Update best accepted displaced solution
    
    if> ( dispdQok>=DISPDQMAX[dispdqlevs] | outdisp==1);  % dispstcode is still =1 here
      dispstate=4;
        % OK step from states 1 and 2: Cause successfull "normal end" for this element
        
    elseif (dispstate==2);                  % Still dispstcode=1. dispokmx=dispnow
      if> (rg);    dispstate=5;
      else; dispnow = dispnow + dispstep;   % The planned new step for this element
            dispstep=1.1*dispstep;          % Only a slight increase because
                                            %.. shortening the step may soon become necessary.
      if!;
    elseif (dispstate==3);                  % Still dispstcode=1. dispokmx=dispnow
      if> (rg);  dispstate=6;               % Convergence without success: indicate failure
      else; dispnow = (dispokmx + dispbadmin) / 2;       % = next displacement moved up
            dispstep = 0.5*dispstep;        % next (shortened) step and convergence criterion
      if!;
    else;    % dispstate==1 or ==0,   dispstcode=1,  dispokmx=dispnow
      dispstate=1;
      dispnow = dispnow + dispstep; 
      dispstep=dispstep+dispstepxx*dispstep;  % Planning longer future steps
    if!;                                 
    dispind=dispind+1; di1=dispind+1;   % End of operations with dispstcode=1
                                        % Previous di1 was saved in e1
    
  elseif (dispstcode==2);  % High-Q step -- any states 0,1,2,3
    dispHQdone=dispHQdone+1; 
    if> (dispstate<2 & deltaq<DISPDQMAX[dispdqlevs]);   % dQ is not very high, first HighQ step
      dispstep=0.6*dispstep;                       % Make shorter steps than previously planned
      dispnow=0.4*dispokmx+0.6*dispnow;  
      dispstate=1;                                 % Let state remain =1
    else;
      dispbadmin=0;   % Ignore earlier badness information that pertains to larger displacements
      dispstate=2;    %.. Leave displ range still open because in High-Q situations Q evaluation 
                      %.. from gradient values is uncertain
      if> (rg);  dispstate=5;        % rg: Convergence of disp steps
      else;    
        if> (deltaq<DISPDQMAX[dispdqlevs]); 
          dispstep=0.6*dispstep;  
          dispnow=0.4*dispokmx+0.6*dispnow;     
        else;
          dispstep=0.5*dispstep;     % Make shorter steps from the previously accepted
          dispnow=0.5*dispokmx+0.5*dispnow;
        if!;
        FREEFACTS[0]=OKDISFACT[0];   % For just in case, load previous OK factors
      if!;
    if!;                             %.. displacement, leaving high end of stepping range open

  elseif (dispstcode==5);    % DISP or BS-DISP, full data or resample, rejected step, goes to
    dispstate=8;             %.. local minimum. This is only place where Q decrease is noted
    sx=-8;                   %.. (dispdQneg was stored earlier)  ---   sx code not used now?
                 
  else;   % Rejected step, dispstcode = 3 (swaps)     (was also:  or 4 (badgrad) )
    dispstate=3; 
    if> (rg);  dispstate=6;          % Convergence without success: indicate failure
    else;
      dispbadmin = dispnow;                      % Move bad-disp indicator halfway down 
      dispnow = (dispokmx  +  dispbadmin)/2;   % Set next displacement to middle of range
      dispstep  = 0.5*dispstep;
      FREEFACTS[0]=OKDISFACT[0];     % There may be a swap in freefacts --> retry from best-fit
    if!;
  if!;     
     
  if> (dispstate<4 & dispind>dispmxnum);   % Allowed # of disp-steps done, no success:
    dispstate=7; sx=-4;                    % What is this? An undocumented error indicator?
  if!;                                     % Does not happen except very rarely???
  
  if> (dispstate>3);
    write 40, '(/A)', '  j2, jp, up, out, final state, final step code=';
    write 40, '(I5)',    dispj2, dispjp, dispup, outdisp, dispstate, dispstcode;
  elseif (dispstcode>1);
    write 40, '(/A/)', '  REJECTED: _state _stcode dispokmx dispbadmin DISPLTABLE';
    write 40, '(I3)',    dispstate, dispstcode;
    write 40, '(E13.3)', dispokmx, dispbadmin ;
    for> kk=1:1:5;  write 40, '(E13.3)', DISPLTABLE[e1,kk];
    for!;       
  if!;
    
  if> (dispstate==5);          % Convergence after High-Q 
    for> dl=1:1:dispdqlevs;
      % Step through dQmax levels, find those that have not been reached by accepted displ.
      if> (DISPDQMAX[dl] > dispdQok); 
        DISPBCMIX[dispj2,dispjp,dl,dispud]=BESTBBCC[dispj2,dispjp]+dispnow;  
        DISPSTATS[dispj2,dispjp,dl,2+dispud]=0;           % status = "normal"
      if!;
    for!;
    DISPBCHIQ[dispj2,dispjp,dispud]=DISPDQMAX[dispdqlevs]+1.0;  % Signal for HighQ
    dispstate=4;               % End OK, store results
  if!;
  
  if> (dispstate==4);
  % Successful end with this factor element. Store the results. For cases that
  % get dispstate=4 after this point, there will be no storing of results, such
  % displacements are "rejected".
  %   By using the interpolated BBCC, update min and max of all BBCC elements 
  %   for all dQmax levels
    Bmin{DISPBCMIX[0,0,0,3],NaN,DISPBCMIX[0,0,0,3],DISPBCINT[0,0,0]};
    Bmax{DISPBCMIX[0,0,0,4],NaN,DISPBCMIX[0,0,0,4],DISPBCINT[0,0,0]};
    for> dl=1:1:dispdqlevs;                % Estimate column-scaled BB or F factors       
      for> j2=1:1:n2;                      % do not process C factor values at all
        as=Arrsum{DISPBCINT[j2,0,dl]};
        if> (as>0);           % If as (= old sum) is >0, insert values scaled 
          as=dispFscale/as;   % so that new_sum=dispFscale
        else;       as=0.0;   % If old sum is <=0, insert zeros in scaled matrix
        if!;
        Blincomb{DISPBCINT[j2,0,dl], as,DISPBCINT[j2,0,dl]};  %multiply column by as
      for!;
    for!;        % Update column-scaled min and max of BB elements
    Bmin{DISPBCMIX[0,0,0,5],NaN,DISPBCMIX[0,0,0,5],DISPBCINT[0,0,0]};
    Bmax{DISPBCMIX[0,0,0,6],NaN,DISPBCMIX[0,0,0,6],DISPBCINT[0,0,0]};
  if!;   % Earlier, these commands were executed below, with next test of dispstate==4

  if> (errestmode<-2.5 & dispstate==8);          % 8: BS-DISP ends with failure.
    if> (dispbsnumb==1);
      write 40, '(///A/)',  '  Q decreases --> local minimum -- when DISPing full data';
      disprejsco=Maxval{disprejsco,9};
    else;
      write 40, '(///A)',  '  Q decreases --> local minimum -- when DISPing resample #';
      write 40, '(I8/)',  dispbsnumb-1;       %.. may also report for full-data DISPing
      disprejsco=Maxval{disprejsco,4};
    if!;
    DISPREJCNT[1]=DISPREJCNT[1]+1;
  elseif (dispstate==8);                         % 8: DISP ends with Q decrease.
    write 40, '(///A/)',  '  Q decreases --> local minimum found in DISP analysis';
    disprejsco=9;
  elseif (dispstate==6 | dispstate==7);           % 6,7: DISP or BS-DISP fail, usually swaps. 
    write 40, '(///A/)',  '  Factor swap detected';
    DISPREJCNT[3]=DISPREJCNT[3]+1;                % Count occurrence of swaps
    if> (dispbsnumb<=1); disprejsco=Maxval{disprejsco,6};  % Full data, (BS)DISP, severe error!
    else;                disprejsco=Maxval{disprejsco,2};  % BSDISP resample, who cares?
    if!;
    if> (sx==0 | sx==1);    % If there have been successful (short?) steps after a bad step,
      sx=DISPLTABLE[1,6];   % retrieve the reason for the problem, the last fatal swap code
    if!;                    % from its special save location, saved some 200 lines back
    for> dl=1:1:dispdqlevs;              % Loop through not-reached levels
      if> (DISPDQMAX[dl] > dispdQok); 
        DISPBCMIX[dispj2,dispjp,dl,dispud]=BESTBBCC[dispj2,dispjp]+dispokmx;  
        DISPSTATS[dispj2,dispjp,dl,2+dispud]=sx;    % status = swapping (or too many steps?)
        Blincomb{SMALLDIA[dl+3,0], 1.0,SMALLDIA[dl+3,0], 1.0,SMALLDIA[3,0]};
            % Update swap summary for those dQmax that were not reached
      if!;
    for!;
    DISPBCHIQ[dispj2,dispjp,dispud]=dispdQok;       % Will be < DISPDQMAX[dispdqlevs]
  if!;  
 
  if> (dispstate>5.5);  % Was there a problem? Should it be played down?
                        % N.B. in any case, the erroneous DISP was not stored, it is "ignored".
    if> (disprejsco<disprejthr);   % Yes, ignore it, call this a "ready" DISPing, state=4, no storage
      dispstate=4; disprejsco=0;            % end this fact, reset reject score if below threshold
    elseif (disprejsco==2 & disprejthr==2);  % if delayed reject called for,
      dispstate=4;                           % end this fact, no storage, do not reset error indicator
    if!;                                     % reject later, when resample is ready
  if!;
                                % Not ignoring, score is high enough vs. threshold
  if> (dispstate>5.5);          % (6, 7, 8) aborting because of different failures: MUST 
    BBCC.fkey[dispj2,dispjp]=BCKEYLOHI[dispj2,dispjp,1];   %.. release displaced element
    if> (errestmode>-2.5);       % pure DISP: End the run after this task.
      for> fi={6,24,40};
        write fi, '(/A)',    '  DISP estimation aborted without writing results';
        if> (dispstate==8);  write fi, '(/A)',
           '  because Q value decreased significantly from supposed best-fit value';
        else;                write fi, '(/A)',
           '  because factor swaps have been detected';
        if!;
      for!;
      numtasks=taskcount;    %..  Before ending, output results.
    else;       % BS-DISP, rejection that exceeds rejection threshold
      if> (disprejsco>5); bsphase=-6;   % abort the run
      else;               bsphase=-4;   % reject resample
      if!;
    if!;
  elseif (dispstate==4);   % End this element, begin a new one.
    % Ready with this factor element. For successful endings, results have already been
    % stored. For error endings without rejection/abort, no storage, only diagnostic outputs:
    for> ep=1:1:e1;       % Diagnostic output to .txt file
      write 40, '(/)';
      for> kk=1:1:5;  write 40, '(E13.3)', DISPLTABLE[ep,kk];
      for!;       
      for> kk={6, 7}; write 40, '(I8)',   DISPLTABLE[ep,kk];
      for!;
    for!;    
    write 40, '(/)';
    write 40, '(/,15E13.3)', DISPBCMIX[dispj2,dispjp,0,1],DISPBCMIX[dispj2,dispjp,0,2];
     
    write 40, '(//A)',  '  Table T1 = approximation of last perturbed G1 by 1st best-fit G0';
    write 40, '(/A)',   '  Column k of T1 contains coefficients for column k of matrix G1:';
    callsubr Fwrite2{40, '(30(1X,F6.3,:))', '(1X)'}{CORREL};  % CORREL computed some 200 lines back
 
    
    jj=0;              % Collect swap info (only for tasks that stored results to DISPLTABLE)
    for> ep=dispmxnum:-1:1;                  % Find last location (i.e. largest displacement)
      if> (DISPLTABLE[ep+1,6]>0 & jj==0);    %.. where a swap occurs
        jj=ep+1;                             % jj=DISPLTABLE index where swap occurs
        ii=DISPLTABLE[ep+1,6];               % ii=severity code = # of swaps
      if!;
    for!;
    if> (jj>0);  SWAPTABLE[taskxcount,0]={ dispj2,dispjp,dispup,ii,
          (DISPLTABLE[jj-1,5]+DISPLTABLE[jj-1,7]), (DISPLTABLE[jj,5]+DISPLTABLE[jj,7]) };
    if!;
    
    BBCC.fkey[dispj2,dispjp]=BCKEYLOHI[dispj2,dispjp,1];   
    % release the displaced element. This MUST be done even in reject situations

   % We have still (errestmode<-1.5 & taskxcount>1 & dispstate==4) -------------------------------
 
    callsubr Dispnext{}{};    % called for selecting next BB/CC element, up or down. 
                               % dispj2,dispjp did change. 
     % other parameters will be set later, in preproc of next task.
  
    if> (dispstate==-1);       % If Dispnext failed, was it for up-pulling task?
      if> (dispup==1);         %.. Yes. It was the last up-task.
        for> fi={6,24,40};
          write fi, '(/A/)', '  All DISP up tasks have been computed. taskcount, taskxcount=';
          write fi, '(I8)', taskcount, taskxcount;
          write fi, '(/)';
        for!;
        dispstate=-2;             % Initiate down DISPing in this call of Dispnext
        callsubr Dispnext{}{};    % Select first BB element for displacing down
           % This could only fail if all unmasked elements have already reached
           % their low limits with all dQ levels. Check and report.
        if> (dispstate==-2); 
          for> fi={6,24,40};  write fi, '(A/)', '  No DISP down tasks to compute.';
          for!;
          if> (errestmode>-2.5);   % pure DISP: End the run after
            numtasks=taskcount;    %.. this task. Before ending, output results.
          else;
            bsphase=-3;            % BS-DISP: Output results from this resample
          if!;
        if!;    
      else;                     %.. No. It was the last down-pulling task
        for> fi={6,24,40};
          write fi, '(/A)',    '  Estimated errors with dQmax values';
          write fi, '(10F7.1)', DISPDQMAX[0];
          write fi, '(/A/)',   '  All DISP down tasks have been computed. taskcount, taskxcount=';
          write fi, '(I8)', taskcount, taskxcount;
          write fi, '(/)';
        for!;
        if> (errestmode>-2.5);   % pure DISP: End the run after this task.
          numtasks=taskcount;    %..  Before ending, output results.
        else;
          bsphase=-3;            % BS-DISP: Output results from this resample
        if!;
      if!;      
     else;    % Dispnext did not fail, new element/level was set.
      if> (taskcount==numtasks);
        for> fi={6,24,40};   write fi, '(A/)', 
          '  WARNING: numtasks is too small. Some estimations must be omitted';
        for!;
      if!; 
    if!;     % Tested Dispnext for next BB/CC element/level. If failed, summary output
             %.. (in last task) will be performed near the end of postprocessing
  if!;     % Ending operations with dispstate=4 (finishing with one perturbed element)
% ending DISP or BS-DISP postproc DISPing operations with (errestmode<-1.5 & taskxcount>1)
%
if!; 
                                     % -3:  Normal end for one BS-DISP resample
if> (bsphase==-3);                   % All displacements computed for one resample by BS-DISP
  if> ( disprejsco < disprejthr );   % Rejectscore is < threshold, accept results
    dispbsOKn=dispbsOKn+1;           % Count accepted resamples that are to be output later
    for> ii=1:1:4;
      BSDISPRES[0,0,0,dispbsOKn,ii]=DISPBCMIX[0,0,0,ii+2];
    for!;
  if!;
if!;

if> (bsphase==-3 | bsphase==-4 | bsphase==-6);    % -6: reject BS-DISP run  -4: reject resample
    % Current perturbed resample aborted or fully processed, or current resample best-fit fails? 
  write 40, '(//A)',  '  BS-DISP computations finished with resample #';
  write 40, '(I8)',  dispbsnumb-1;
  write 40, '(/A)',  '  dispreject score, bsphase =';
  write 40, '(I8)',  disprejsco, bsphase;
  if> (dispbsnumb>=numbstasks | bsphase==-6);     %.. If it was last resample, or aborting the run,
        bsphase=-5;           %.. end run now. Indicate final output and end the run
        numtasks=taskcount;   % Increasing numtasks will trigger final output later on, 
                              % then ends the run after postproc ends
  else; bsphase=-1;   
  if!;               % Read next resample from BStoDISP.dat
if!;


% Postprocessing: Write computed factor matrices to file 40
% ---------------------------------------------------------
if> (taskcount<=numtasks);       % do not write if run is cancelled
  if> (simu<2.5 | simu>3.5 |taskxcount<6);  
                      % for simu=3, only write in first 5 tasks
    if> (taskcount==1 & (errestmode>0.5 | errestmode<-1.5)); 
      ##7='Best-fit with original values';
    elseif (errestmode>0.5 & bsphase==1);   ##7='Bootstrapped values';
    elseif (errestmode>0.5 & bsphase==2);   ##7='Bootstrapped/pulled values';
    elseif (taskxcount==1 & errestmode<-2.5 ); 
      ##7='Best fit of Resampled Values';
    elseif (errestmode<-2.5 ); ##7='Resampled-displaced fit';
    else; ##7=' ';
    if!;
     
    if> (errestmode>-0.5 | taskcount<4 | taskxcount==1);   
      write 40, '(///3X, A)', 'Factor matrix AA';
      write 40, '(3X, A)', ##7;
      callsubr Fwrite2{40, ##4, '(1X)'}{AA};   % Write AA without row titles
    if!;
    write 40, '(///3X, A)', 'Factor matrix BB';
    write 40, '(3X, A)', ##7;
    callsubr Fwrite2{40, ##3, '(1X)'}{BB};   % Write BB without row titles
    write 40, '(///3X, A)', 'Factor matrix CC';
    callsubr Fwrite2{40, ##3, '(1X)'}{CC};
    write 40, '(/)';
    
    if> (aeruse==1);
      write 40, '(//3X, A)', 'Infiltration factor matrix (in/out)';
      callsubr Fwrite3{40, ##4, '(1X)', 1}{AERPENE};
      write 40, '(//3X, A)', 'Infiltration factor matrix (pers/out)';
      callsubr Fwrite3{40, ##4, '(1X)', 2}{AERPENE};
    if!;
    
    if> (numpf>0.5);
      for> tf=1:1:numpf;   % Write parametric factors if used
        d1=PFDIM[tf];         % Length of the PF vector
        write 40, '(//3X, A)', 'Parametric factors PF #';
        write 40, '(I3,/)', tf;
        for> i1=1:1:d1;
          write 40, '(/1X,I4)', i1;
          write 40, ##4, PF[i1,0,tf];
        for!;
      for!;
      if> (numynpf>0.5);
        write 40, '(//3X, A)', 'Parametric y/n factors';
        for> i1=1:1:numynpf;
          write 40, '(/1X,I4)', i1;
          write 40, ##4, PF[i1,0,numpf+1];
        for!;
      if!;
    if!;
  if!;
if!;    % End of writing computed factors in human-readable form


% Postprocessing: Write true simulated factor matrices 
% ----------------------------------------------------
% Write in .dat style, for import to matlab, say
if> (simu==1 | (simu>1 & taskcount==1));  % E formats not needed (simu only) 
  Bswap{FREEFACTS[0],TRUEFACTS[0]};       % Swap for easier writing
  write 40, '(///3X, A)', 'Factor matrices AA, BB, and CC   True values';
  write 40, ##9, AA[0,0], BB[0,0], CC[0,0];
  write 40, '(//)';
  Bswap{FREEFACTS[0],TRUEFACTS[0]};       % Restore correct values
if!;


%  Write arrays XX.res, XX.sres and AAMSRES (if PF used) with row numbers  
%  If simulation, write titles for arrays.  
% ---------------------------------------------------------------  
if> ( (contrun==0 & simu==0 & taskcount<=numtasks) | 
             (taskcount==1)         );
  if> (gui>0.5 | simu==0);    
    callsubr Xwrite2{##3,41}{XX.res};
    callsubr Xwrite2{##4,41}{XX.sres};
    if> (numpf>0.5);
      callsubr Xwrite2{##4,41}{AAMSRES};
    if!;  
  else;                  % Simulation output
    write 41, '(//A/)', 'Unscaled residuals';
    callsubr Xwrite2{##3,41}{XX.res};
    write 41, '(//A/)', 'Scaled residuals';
    callsubr Xwrite2{##4,41}{XX.sres};
    write 41, '(//A/)', 'True array X';
    callsubr Xwrite2{##3,41}{XXTRUE};
    write 41, '(//A/)', 'Noise-containing array X';
    callsubr Xwrite2{##3,41}{XX};
    if> (bsmode==14 & taskxcount<1.5);  
      write 41, '(//A/)', 'Best-fit X';
      callsubr Xwrite2{##3,41}{BESTFIT};
      write 41, '(//)';
    if!;
  if!;
if!;


splitBScod=1;
% In BS runs, cycle bsphase:  0 --> 1 --> 2 --> 1 --> 2 --> 1 ... 
% ----------------------------------------------------------------- 
if> (errestmode>0.5);
  if> (bsphase==1 & errestmode<1.5);   % Only for errestmode==1,
    nonpullQ=mainqvalue;               % phase 1  -->  phase 2
    bsphase=2;    
    if> (splitBSres==2); splitBScod=2;
    if!;
  elseif (bsphase==2);   
    dq=mainqvalue-nonpullQ;
    deltaQmax=Maxval{dq,deltaQmax};
    deltaQmin=Minval{dq,deltaQmin};
    bsphase=1;
  else;         % if taskcount=1,  bsphase  0 --> 1
    bsphase=1;
  if!;
if!; 


% The rest of postprocessing does not use bsphase
fi=40;   % just in case...

% Postprocessing, only for last task after this point:
% When ending last BS-DISP task: write min-max estimates to dedicated files
% -------------------------------------------------------------------------
if> (taskcount>=numtasks & errestmode<-2.5);   % Only for BS-DISP

  write fi, '(///A)',  
   '  Summary of BS-DISP analysis (all resamples have been processed)';
  write fi, '(A/)',   '  ################################';
  write fi, '(A)', 
   '  ===============================================================';
  nh=Roundtonea{dispbsOKn/2-0.1};  % Halfway-value between min and max estimates
  fi=40;
  write fi, '(//A,3X)',  '  DISP-induced largest decrease of Q in the whole run  =';
  write fi, '(F10.3)', dispdQneg; 
  write fi, '(//A)',  '  # of swap failures in each factor for each dQmax';
  write fi, '(/A)',  '  (swap failure means that dQmax in question is not reached)';  
  for> dl=1:1:dispdqlevs;
    write fi, '(/2X,A,3X)', DISPDQHEAD[dl,1];
    write fi, '(30I5)', SMALLDIA[dl+3,0];
  for!;  
  write fi, '(//A/14X)',  '  # of cases of /drop of Q / swap in best fit / swap in DISP/';
  write fi, '(10I12)',  DISPREJCNT[0];
  
  write fi, '(//A/)', '  # of accepted & rejected resamples, including full-data case =';
  write fi, '(I10)',    dispbsOKn, dispbsnumb-dispbsOKn;
  write fi, '(/)';
  
  for> dl=1:1:dispdqlevs;          % Write min & max estimates from all resamples
    d8=80+dl;                      % Write in separate files for each dQmax
    
    write d8, '(I8)',    dispbsOKn;        % Write number of cases in file
    write d8, '(F10.3)', dispdQneg;        % Write max decrease of Q in all output files
    write d8, '(10I8)',  DISPREJCNT[0];    % Write # of rejects caused by 3 reasons
    
    for> dx=1:1:dispdqlevs;                  % Write full table of swap failures in
      write d8, '(/30I5)', SMALLDIA[dx+3,0];  %.. each output file
    for!;       
    write d8, '(/)';             
    
    for> nb=1:1:dispbsOKn;   
      for> uu={1,2,3,4};             % Write min F&C values for task nb (uu=1)
        for> j2=1:1:n2+1;            %.. and max values (uu=2)
          write d8, '(/I6)', nb;     % Write min scaled F values for task nb (uu=3)
          write d8, '(I6)', j2;      %.. and max values (uu=4)
          write d8, ##3, BSDISPRES[j2,0,dl,nb,uu];
        for!;
        write d8, '(/)';       % Extra line feed, separating min and max of resample nb
      for!;    
    for!;
    write d8, '(/)';             

    for> jp=1:1:np;           % Sort BS-DISP min and max estimates over all tasks
      for> j2=1:1:n2+1;       %.. for all BBCC elements, for dQmax level dl
        Bsort{BSDISPRES[j2,jp,dl,0,1]};  % Sort min estimates
        Bsort{BSDISPRES[j2,jp,dl,0,2]};  % Sort max estimates
      for!;
    for!;
    for> nb=1:1:nh;                     % Copy lower 50% of min estimates (1) over to
      BSDISPRES[0,0,dl,nb,2]=BSDISPRES[0,0,dl,nb,1];   % corresponding max estimates (2)
    for!;
    
    write d8, '(//)';          % Extra linefeeds between unsorted and sorted
    for> nb=1:1:dispbsOKn;     % Write sorted displaced min and max values
      for> j2=1:1:n2+1;        
        write d8, '(/I6)', nb;  
        write d8, '(I6)', j2;
        write d8, ##3, BSDISPRES[j2,0,dl,nb,2];
      for!;
      write d8, '(/)';         % Extra line feed, separating different sorted indices
    for!;
    write d8, '(/)';           % Extra line feed 
  for!;                 % closing the loop over dQmax levels
if!;              % if> (taskcount>=numtasks & errestmode<-2.5);   % Only for BS-DISP

fi=40;   %just in case...

% Postprocessing, when ending last task:
% Formulate and write summary information. Both BS and pure DISP.
% ------------------------------------------------------------------
if> (taskcount>=numtasks);
  write 40, '(//,5X,A)',   'task#   Qmain      Qaux       Q(XX)   dQ<0';
  if> (doresort~=0);
    write 40, '(A)', '       factor "correlations" with', ##s;
  if!;
  for> ii=1:1:numtasks;       % Write table of Q values, and of correlations if computed
    write 40, '(/I8)', ii;
    write 40, '(F11.3)', QTABLE[ii,1], QTABLE[ii,2], QTABLE[ii,3];
    if> (QTABLE[ii,4]<-1.0);  write 40, '(F8.3,3X)',  QTABLE[ii,4];
    else;                       write 40, '(11X)';
    if!;
    if> (doresort~=0);  write 40, '(50(1X,F6.3,:))', CORRTABLE[ii,0];
    if!;
  for!;
  write 40, '(/)';

  if> (dotable>0.5);
    callsubr Minmaxsetx{1}{};   % Works only for splitBSres=1
  if!;

  % Postprocessing, last task, DISP and BS:
  % ---------------------------------------
  for> z1=1:1:2;
   splitBScod=0;
   if> (errestmode>0.5);
     z2=1;
     if> (z1<=splitBSres); splitBScod=z1;   % may be =2 only if splitBSres==2
     if!;
   elseif (errestmode==-2);      % N.B. BS-DISP has errestmode==-3
    splitBScod=1;
    z2=2*z1-1;     % z1=1,2 --> z2=1,3,  selecting slices of DISPBCMIX for output
   if!;  
   if> (splitBScod>0.5);
     % Arrange for repeated output, both for DISP and for BS.     Not yet for BS-DISP *****
     % BS: Process both pages of BS results (if two pages exist)
     % DISP: Output two sets of results, based on pages (1,2) and on pages (3,4)
     % of array 
     % This if block extends almost to the end of section postproc!
    if> (splitBScod==2);
      write 40, '(////,4X,A,/)',
        'This BS run summarizes unpulled and pulled resamples separately';
      write 40, '(4X,A,/)', 
        'because splitBSres=2.  Preceding output was for unpulled only.',
        'Next output will be for pulled only. Some results will appear twice.',
        'File 51, "PMF_BS.dat", will also contain two sets of results, ',
        'first for unpulled, then for pulled replications';
      write 40, '(//)';
      DISPSTATS[0,0,0,0]=0;   % Reset error indicators for 2. page of BS results
    if!;
    if> (dotable>0.5);  
      VIOLCOUNTS[0,0]=0;  % Counters for confidence interval violations
      CONFILEN[0,0]=0;    % (may be re-used for the second BS page)
      % Format ##1 used for writing computed values   
      % Format ##2 used for writing AA fill-in (best-fit) values 
      ab=2;       % ab=2 indicates: omit A factor elements,
                  % only process B, C, etc factor elements
    
    
      for> jj=n1*np+1:1:numfreef;       % loop over BB, CC, PF, CM factors 
        jb=jj-n1*np;                    % jb is index to BB and CC

% Last task. For BS simulation, count violations, i.e. the cases where true
% value is outside any of its corresponding CI's. Count left and right
% ends separately. (So far, only tested for simu=3.)
% Also, load min&max values in DISPBCMX in order to use DISP output
% --------------------------------------------------------------------
        if> (dotable==2);    % simulations only, for BS and for repeated analyses
          rr=TRUEFACTS[jj];
          for> ii=1:1:numextrem;
            mi=MINMAXFACT[jj,ii,splitBScod];
            kk=dispdqlevs-ii+1;    % steps from dispdqlevs to 1 (to 0, ... )
            if> (jb>0 & jb<=(n2+1)*np & kk>0); 
              DISPBCMX[jb,1,kk,1]=mi;
            if!;
            if> (rr<mi); 
              VIOLCOUNTS[ab,ii]=VIOLCOUNTS[ab,ii]+1; 
            if!;
            ci=MINMAXFACT[jj,2*numextrem+1-ii,splitBScod]-mi;
            CONFILEN[ab,ii]=CONFILEN[ab,ii]+ci;     % Accumulate sum
          for!;
          for> ii=numextrem+1:1:2*numextrem;
            ma=MINMAXFACT[jj,ii,splitBScod];
            if> (rr>ma); 
              VIOLCOUNTS[ab,ii]=VIOLCOUNTS[ab,ii]+1; 
            if!;
            kk=ii-2*numextrem+dispdqlevs;   % last kk = dispdqlevs --> longest CI
             % kk steps from 1 to dispdqlevs to ...
            if> (jb>0 & jb<=(n2+1)*np & kk>0); 
              DISPBCMX[jb,1,kk,2]=ma;
            if!;          
          for!;
          write 51, ##1, rr;  % Write true as 1st column in table, when known
        if!;   % end if for simulations only
      
% Last task. For real data and for simulation, write a summary table  
% of BS replications of B factor elements to file 51
% (for details of table, see documentation at the top of the script)
% ------------------------------------------------------------------
        ff=BESTFACTS[jj]; 
                            % (already wrote true value, if simulation)
        write 51, ##1, ff,  % write best-fit,
          MINMAXFACT[jj,0,splitBScod];    % min1,min2, ..., max2,max1 values 
        write 51, '(2X)';   % Write divider space between CI end values
                            % and results from separate tasks
        for> ii=1:1:numtasks;             % As a visual aid, we can write filler values 
          tt=RESLT[jj,ii,splitBScod];     % in different format than the actual values
   %       if> (tt>-99920);  % If it is an unused position in the table,
   %                          %.. do not write anything at all
            if> (tt<-99920);        % Now it is a non-sampled or pulled row,
   %           write 51, ##2, ff;    %.. write filled (best) value 
              write 51, ##2, tt;    %.. write marker code
            else; write 51, ##1, tt;    % It is a sampled non-pulled row:
            if!;                        %.. write actual computed value
   %       if!;
        for!;
        write 51, '(/)';
        if> (Mod{jj,np}==0);  write 51, '(/)';
        if!;
      for!;      % end of loop over all BB CC PF CM factor elements 
      write 51, '(/)';
    if!;   % ending dotable>0.5 for last task
  
  
% Last task. Prepare average BS CI length values, write summary
% table about BS CI lengths and violations (only for simulation)
% (still inside the splitBScod loop)
% -------------------------------------------------------------- Not yet for BS-DISP *****
    for> ii=1:1:numextrem;
      CONFILEN[1,ii]=CONFILEN[1,ii]/(n1*np); % A averages -- not used
      CONFILEN[2,ii]=CONFILEN[2,ii]/(n2*np); % B averages
    for!;
    if> (dotable==2);     % - simu only -,   not used by EPA PMF v1
      fi=40;              % For non-GUI, write to files 40 and 48
      while> (fi>0);      % For gui>0.5, only write to file 40
        write fi, '(/2X,A)', 'c1, c3 ='; 
        write fi, '(1X,F7.3)', c1, c3;
        if> (acbmodel);  
          write fi, '(/2X,A,2X)', 'Simulated A*C*B model is fitted. Seeds:';
        else;            
          write fi, '(/2X,A,2X)', 'Simulated A*B model is fitted. Seeds:';
        if!;
        write fi, '(5I6,/)', SEEDS[0];
        write fi, '(2X,A)', 
         'Analysis of BS confidence intervals (CI), file =', ##b;
        write fi, '(/2X, A/)', 'bsmode, alowlim';
        write fi, '(1X,I6)',    bsmode;
        write fi, '(1X,F8.3)', alowlim;
        write fi, '(/2X, A/)', '   wga     pullc1'; 
        write fi, '(1X,F8.3)',     wga,    pullc1; 
        write fi, '(/2X,A)', 
          'Max and Min deltaQmain, as caused by BS random pulling:';
        write fi, '(F12.4)', deltaQmax, deltaQmin;      
        write fi, '(/)';
      
        ab=2;
        write fi, '(1X,A/)', 
           'BS Confidence Interval average lengths, averaged over', 
           'all B, C, etc factor elements, averaged separately for',
           '6 CIs based on most extreme, 2 ... 6th extreme values';
        write fi, '(2X,10F12.4)', CONFILEN[ab,0];
        write fi, '(//)';
        write fi, '(1X,A/)', 
           'Overall "violation" counts of B, C, etc factor elements,', 
           'for which true values are out of the 6 BS CIs,';
        write fi, '(1X,A)',
            '        out past low ends     ...     out past high ends';
        write fi, '(/2X,20I5)', VIOLCOUNTS[ab,0];
        write fi, '(/)';
        if> (fi==40 & gui<0.5); fi=48;
        else; fi=0;
        if!;
      while!;    
    if!;   % ending dotable==2 for last task
  
  
% Postprocessing (for DISP, partly also for BS):
% (later also for BS-DISP ??)
% Last task. Write man- and machine-readable tables of DISP results.
% Evaluate confidence of dQ-based "disp" CI's of perturbed elements.
% Output error estimates (CI's) for dQ-controlled pulling
% DISPSTATS have been reset to zero early in section equations
% ------------------------------------------------------------------ Not yet for BS-DISP *****
    if> (errestmode<-1.5 | dotable==2);
      fi=40;           %  write to file 40 and to dedicated DISP output files
      if> (errestmode<-1.5);
        BADCOUNTS[0]=0;           % Writing machine readable tables
        for> dl=1:1:dispdqlevs;
          if> (dl>1.5);  % Min of higher level must not be > min of lower level, recursively
                         % Max of higher level must not be < max of lower level, ..
            Bmin{DISPBCMIX[0,0,dl,z2],  NaN,DISPBCMIX[0,0,dl,z2],  DISPBCMIX[0,0,dl-1,z2]};
            Bmax{DISPBCMIX[0,0,dl,z2+1],NaN,DISPBCMIX[0,0,dl,z2+1],DISPBCMIX[0,0,dl-1,z2+1]};
          if!;
          write 51, ##9, DISPBCMIX[0,0,dl,z2],
                         DISPBCMIX[0,0,dl,z2+1];
          write 51, '(/)';
          if> (z2==3);       % Write to dedicated DISP output files 81..84
            d8=80+dl;
            write d8, '(/I8)',   disprejsco;    % =0, 6, or 9:  no reject, swap reject, Q drop reject
            write d8, '(F12.3)', dispdQneg;
            for> dx=1:1:dispdqlevs;                  % Write full table of swap failures in
              write d8, '(/30I5)', SMALLDIA[dx+3,0];  %.. each output file
            for!;       
            write d8, '(/)'; 
            write d8, ##9, DISPBCMIX[0,0,dl,3], DISPBCMIX[0,0,dl,4];
            write d8, ##c, DISPBCMIX[0,0,dl,5], DISPBCMIX[0,0,dl,6];
          if!;
        for!;
        write 51, ##a, DISPBCHIQ[0,0,1], DISPBCHIQ[0,0,2];
        write 51, '(/)';
        write 51, '(/30I5)', SMALLDIA[2,0];
        write 51, '(/)';
        for> dl=1:1:dispdqlevs;
          write 51, '(/30I5)', SMALLDIA[dl+3,0];
        for!;       
        write 51, '(/)';     % BADCOUNTS will be computed & written to 51 later!
      elseif (splitBScod==2);
        write 51, '(30I5)', SMALLDIA[2,0];
        write 51, '(/)';
      if!;
   
      es=0;               % Will count failing up-estimations
      for> jp=1:1:np;     % compile DISPSTATS indicators (DISP and BS)
        for> j2=1:1:n2+1;
          if> (DISPBCMASK[j2,jp]==1);
            for> dl=1:1:dispdqlevs;
              if> (errestmode<-1.5);
                if> (DISPBCHIQ[j2,jp,1]<DISPDQMAX[dl]);
                  BADCOUNTS[dl]=BADCOUNTS[dl]+1;
                if!;
                if> (DISPBCHIQ[j2,jp,2]<DISPDQMAX[dl]);
                  BADCOUNTS[dl]=BADCOUNTS[dl]+1;
                if!;
              if!;
              e2=DISPBCMIX[j2,jp,dl,z2+1];
              if> (simu>0 & TRUEBBCC[j2,jp]>e2 & e2>=-700);  % not an indicator
                DISPSTATS[j2,jp,dl,2]=1;
              elseif (-800 < e2  &  e2 < -700);  % short-disp indicator
                es=es+1;
              if!;
              if> (simu>0 & TRUEBBCC[j2,jp]<DISPBCMIX[j2,jp,dl,z2]);
                DISPSTATS[j2,jp,dl,1]=1;
              if!;
            for!;
          if!;
        for!; 
      for!;    % DISPSTATS/BS violation indicators compiled
      
      if> (errestmode<-1.5);   % This for DISP (later also for BS-DISP ??)
        write fi, '(///)';
        write fi, '(A/)', 
         '  Results for error estimation by dQ-controlled perturbations',
         '  ===========================================================';
        if> (z1==1);
          write fi, '(A/)', 
               '  First set of results: only actively pulled values';
        else;
          write fi, '(A/)', 
               '  Second set of results: active and passive changes observed';        
        if!;
        write fi, '(2X,A)', 
          'Same tables (machine readable) are output to file', ##b;
        if> (es>0);  write fi, '(/A)',
         '  # of failed estimations in DISP up_displacements';
          write fi, '(I6)', es;
        if!;
        write fi, '(/)';
        if> (Arrmaxval{SWAPTABLE[0,0]}>0); write fi, '(/A)', 
         '  Summary of results where factor identities may have swapped',
         '  -----------------------------------------------------------',      
         '  With one or several perturbations, factor identities',
         '  may have swapped. Below, a list of matrix element F(jp,j2)',
         '  indices and up=1/down=-1 indicators for suspect cases.',
         '  Factor swap is likely if severity is >1',
         '      j2      jp  u=1/d=-1  severity  dQ(OK)   dQ(swap)';
          for> ii=1:1:taskxcount;
            if> (SWAPTABLE[ii,1]>0);
              write fi, '(/,I8)', SWAPTABLE[ii,1];
              write fi, '(I8)',   SWAPTABLE[ii,2], SWAPTABLE[ii,3], SWAPTABLE[ii,4];
              write fi, '(F10.1)', SWAPTABLE[ii,5], SWAPTABLE[ii,6];
            if!;
          for!;
        if!;      
        write fi, '(/)';
        if> (doresort>0.5);  write fi, '(/A)', 
           '  Warning: sorting of factors was enabled in this run.',
           '  DISP error limits are meaningless if any sorting has occurred!'; 
          write fi, '(/)';
        if!;
    
        for> dl=1:1:dispdqlevs; 
          WTEMP[0,0]=DISPBCMIX[0,0,dl,z2+1];
          write fi, '(//A)',  '  Max F (and C) values for DISP delta-Q limit value';
          write fi, '(2X,F10.2)', DISPDQMAX[dl];
          callsubr Fwrite2{fi, ##3, '(1X)'}{WTEMPACB}; 
          WTEMP[0,0]=DISPBCMIX[0,0,dl,z2];
          write fi, '(/A)',  'Min F (and C) values for same dQ limit';
          write fi, '(2X,F10.2)', DISPDQMAX[dl];
          callsubr Fwrite2{fi, ##3, '(1X)'}{WTEMPACB};      
        for!;
        write 51, '(/30I5)', BADCOUNTS[0];
        write 51, '(/)';
      if!;  % ending (errestmode<-1.5)

                                           % For both DISP and BS: Not yet for BS-DISP *****
      if> (dispdQneg<-0.5);
         write fi, '(/A)', 
         ' In DISP estimations, Q decreases (once or several times) ',
         ' when a factor value is displaced from its best-fit value.',
         ' Largest decrease of Q was = ';
         write fi, '(F10.3,/)', dispdQneg;
      if!;                         
      write fi, '(/A)', 
       '  Error indicator codes, after questionable error estimates:',
       '    **   true value not bracketed by this error estimate',
       '    k>0  k is # of (possibly) swapped factors',
       '    -1   computed displacements do not reach specified dQmax';
    
      if> (simu==0 & bsinitfact==1);    ##t='   Init'; 
      elseif (simu==0 & bsinitfact==0); ##t='   Best';
      else;                             ##t='   True';
      if!;
      for> j2=1:1:n2+acbmodel;       % Are there any actively estimated on row j2:
        if> (  errestmode>0.5 | 
              (errestmode<-1.5 & (z1==2 | Arrmaxval{DISPBCMASK[j2,0]}>0.5) )  );
          write fi, '(//A)',  '  Estimates and';
          write fi, '(A)',    ##t, ' values for';
          if> (j2>n2);
            write fi, '(A/)',  '   C coefficients';
          else;
            write fi, '(A)',  '   F variable # ';
            write fi, '(1X,I3/)', j2;
          if!;
        
                                       % simu: ##6='(A9,2X)'; 
          write fi, '(A)', '  Fact';     % non-: ##6='(A11,5X)';
          for> dl=1:1:dispdqlevs;  write fi, ##6,  ' Lowlim';
          for!;
          write fi, ##6, ##t;            % ##t is string of 8 chars
          for> dl=1:1:dispdqlevs;  write fi, ##6,  '  Hilim';
          for!;
          write fi, '(/7X)';
          for> dl=dispdqlevs:-1:1;  write fi, ##6, DISPDQHEAD[dl,1];
          for!;
          write fi, ##6, ' ';  
          for> dl=1:1:dispdqlevs;  write fi, ##6, DISPDQHEAD[dl,1];
          for!;
          for> jp=1:1:np;
            if> ( errestmode>0.5 |         
                  (errestmode<-1.5 & (z1==2 | DISPBCMASK[j2,jp]>0.5)) );
              write fi, '(/I6)', jp;       % simu: ##5='(1X,F7.3,1X)'; 
              for> dl=dispdqlevs:-1:1;     % non-: ##5='(1X,E12.3,1X)';
                write fi, ##5, DISPBCMIX[j2,jp,dl,z2];  % Lower limits
                st=DISPSTATS[j2,jp,dl,3];
                if> (st~=0);  write fi, '(I2)', st;  % Error indicators
                elseif (DISPSTATS[j2,jp,dl,1]>0); 
                  write fi, '(A)', '**';             % Violation indicators
                else;         write fi, '(2X)';
                if!;
              for!;
              write fi, ##5, TRUEBBCC[j2,jp];  write fi, '(2X)';
              for> dl=1:1:dispdqlevs;  
                write fi, ##5, DISPBCMIX[j2,jp,dl,z2+1];  % Upper limits
                st=DISPSTATS[j2,jp,dl,4];
                if> (st~=0);  write fi, '(I2)', st; 
                elseif (DISPSTATS[j2,jp,dl,2]>0); write fi, '(A)', '**';  
                else;         write fi, '(2X)';
                if!;
              for!;    % Loop over dQ levels
            if!;
          for!;      % Loop over factors
        if!;       % Test if any actively estimated factors on row j2
      for!;        % Loop over j2 values
      
      if> (simu>0);     % write statistics of violations
        write fi, '(//2X,A)',
          'Violations (=1):  true<min (left table), true>max (right table)';
        for> j2=1:1:n2+acbmodel;   % Loop over each variable
          write fi, '(/2X,A)', 'j2=';
          write fi, '(I3)', j2; 
          for> dl=1:1:dispdqlevs;
            write fi, '(/2X,A,3X)', DISPDQHEAD[dl,1];
            write fi, '(30I3)',  DISPSTATS[j2,0,dl,1];
            write fi, '(3X)';
            write fi, '(30I3)',  DISPSTATS[j2,0,dl,2];
          for!;
        for!;
       
        write fi, '(//A)',
         '  Summary: # of violations summed over F/C variables';
        for> dl=1:1:dispdqlevs;
          write fi, '(/2X,A,3X)', DISPDQHEAD[dl,1];
          for> ud=1:1:2;
            for> jp=1:1:np;
              write fi, '(I3)',  Arrsum{DISPSTATS[0,jp,dl,ud]};
            for!;
            write fi, '(3X)';
          for!;
        for!;      
        write fi, '(//2X,A)',  
         'Summary: # of violations summed over F/C variables and factors';
        for> dl=1:1:dispdqlevs;
          write fi, '(/2X,A)', DISPDQHEAD[dl,1];
          write fi, '(I6)',  Arrsum{DISPSTATS[0,0,dl,1]},
                             Arrsum{DISPSTATS[0,0,dl,2]};
        for!;    
      if!;   % wrote violations for simu runs
     
     % Compute statistics for CI min/average/max lengths for each dQ level
      CISUMMARY[0,0,0]=0;
 %     write fi, '(//2X,A)', 'Min, Avg, and Max of CI lengths for B (and C) factors';

      write fi, '(//2X,A)',  'For conf-interval lengths of B (and C):';
      write fi, '(/2X,A)',   'B: avg(row_min) avg(row_avg) avg(row_max)',
                             'B: avg(col_min) avg(col_avg) avg(col_max)',
                             'B:   avg of the two rows above this one';
      if> (acbmodel>0.5);
        write fi,'(/2X,A)',  'C:  min(C)        avg(C)        max(C)';
      if!;
      
      for> dl=1:1:dispdqlevs;
        Blincomb{WTEMP[0,0],  1.0, DISPBCMIX[0,0,dl,z2+1],  -1.0, DISPBCMIX[0,0,dl,z2]};
          % WTEMP = CI lengths for one dQmax or one extremeness level
        for> jp=1:1:np;
          CISUMMARY[1,1,dl]=CISUMMARY[1,1,dl]+Arrminval{WTEMPBB[0,jp]}; %col min
          CISUMMARY[1,2,dl]=CISUMMARY[1,2,dl]+Arrsum{WTEMPBB[0,jp]}/n2; %col avg
          CISUMMARY[1,3,dl]=CISUMMARY[1,3,dl]+Arrmaxval{WTEMPBB[0,jp]}; %col max
        for!;
        for> j2=1:1:n2;
          CISUMMARY[2,1,dl]=CISUMMARY[2,1,dl]+Arrminval{WTEMPBB[j2,0]}; %row min
          CISUMMARY[2,2,dl]=CISUMMARY[2,2,dl]+Arrsum{WTEMPBB[j2,0]}/np; %row avg
          CISUMMARY[2,3,dl]=CISUMMARY[2,3,dl]+Arrmaxval{WTEMPBB[j2,0]}; %row max
        for!;
        for> ii={1,2,3};
          CISUMMARY[1,ii,dl]=CISUMMARY[1,ii,dl]/np;
          CISUMMARY[2,ii,dl]=CISUMMARY[2,ii,dl]/n2;
          CISUMMARY[3,ii,dl]=0.5*(CISUMMARY[1,ii,dl]+CISUMMARY[2,ii,dl]);
        for!;
        CISUMMARY[4,1,dl]=Arrminval{WTEMP[n2+1,0]}; %CC min
        CISUMMARY[4,2,dl]=Arrsum{WTEMP[n2+1,0]}/np; %CC avg
        CISUMMARY[4,3,dl]=Arrmaxval{WTEMP[n2+1,0]}; %CC max
      
        write fi, '(//A)', DISPDQHEAD[dl,1];
        for> ii=1:1:3+acbmodel;
          write fi, '(/9F10.3)', CISUMMARY[ii,0,dl];
        for!;
      for!;
                        

      if> (splitBScod==2);
        write fi, '(//A)',  '  # of apparent swaps of each G factor with other G factor(s)';
        write fi, '(/A)',   '  when comparing the pulled BS results with the unpulled ones';
        write fi, '(/30I5)', SMALLDIA[2,0];
        
      elseif (errestmode<-1.5);  % Write twice, for both DISP's         % Not yet for BS-DISP *****
        write fi, '(//A)',  '  # of apparent swaps of each G factor with other G factor(s)';
        write fi, '(/A)',   '  (Includes all computed displacements, even rejected ones!)';
        write fi, '(/30I5)', SMALLDIA[2,0];
          
        write fi, '(//A,3X)',  '  DISP-induced largest decrease of Q in the whole run  =';
        write fi, '(F10.3)', dispdQneg; 
        write fi, '(//A)',  '  # of swap failures in each factor for each dQmax';
        write fi, '(/A/)',  '  (swap failure means that dQmax in question is not reached)';
        for> dl=1:1:dispdqlevs;
          write fi, '(/2X,A,3X)', DISPDQHEAD[dl,1];
          write fi, '(30I5)', SMALLDIA[dl+3,0];
        for!;   
        if> (BADCOUNTS[dispdqlevs]==0);
           write fi, '(//A)',  
           ' Highest dQmax was reached by all displacements, thus there'; 
           write fi, '(/A/)',   
           ' are no failing DISP estimates e.g. because of factor swaps!';
        else;   
          write fi, '(//A)',  '  # of displacements (up&down) not reaching each dQmax level';
          write fi, '(/A)',   '  due to factor swaps (NOT to bad gradients)';
          write fi, '(/30I5)', BADCOUNTS[0];
          write fi, '(///A)',  '  DISP estimations fail in displacing these factor elements';
          write fi, '(/A)',   '   U/D  var. fact.  code   These dQmax OK (=reached)';
          ##u='Down';
          for> ud={1,2};
            for> j2=1:1:n2+acbmodel;
              for> jp=1:1:np;
                rr=DISPBCHIQ[j2,jp,ud];
                if> (rr<DISPDQMAX[dispdqlevs] & DISPBCMASK[j2,jp]>0.5);
                  write fi, '(/2X,A4)', ##u;
                  write fi, '(I6)', j2, jp, DISPSTATS[j2,jp,dispdqlevs,2+ud];
                  if>  (rr<DISPDQMAX[1]);
                    write fi, '(A)',  '  *** all dQmax fail ***';
                  else;
                    for> dl=1:1:dispdqlevs-1;
                      if> (rr>=DISPDQMAX[dl]);  write fi, '(F7.1)', DISPDQMAX[dl];
                      if!;
                    for!;
                  if!;
                if!;
              for!;  % jp loop
            for!;   % j2 loop  
            ##u='  Up';
          for!;     % down/up loop
        if!;     % BADCOUNTS test
      if!;       % DISP estimation
      
      if> (modifcode==2);     % SIE ===========================================
        fi=42;            %  write to file 42, abbrev version of file 40
        if> (simu>0);     % write statistics of violations
          write fi, '(//A)',  
           '  Summary: # of violations summed over variables & factors';
          for> dl=1:1:dispdqlevs;
            write fi, '(/I3)', dl;
            write fi, '(I5)',  Arrsum{DISPSTATS[0,0,dl,1]},
                               Arrsum{DISPSTATS[0,0,dl,2]};
          for!;    
        if!;
        write fi, '(//A)',  '  # of apparent swaps of each factor with other factor(s)';
        write fi, '(/30I4)', SMALLDIA[2,0];
        for> dl=1:1:dispdqlevs; 
          WTEMP[0,0]=DISPBCMIX[0,0,dl,z2+1];
          write fi, '(//A)',  '  Max F and C values for delta-Q limit value';
          write fi, '(2X,F10.2)', DISPDQMAX[dl];
          callsubr Fwrite2{fi, ##3, '(1X)'}{WTEMP}; 
          WTEMP[0,0]=DISPBCMIX[0,0,dl,z2];
          write fi, '(/A)',  'Min F and C values for same dQ limit';
          write fi, '(2X,F10.2)', DISPDQMAX[dl];
          callsubr Fwrite2{fi, ##3, '(1X)'}{WTEMP};      
        for!;
      if!;      % End of optional compact output to file 42
      % SIE ==================================================================
      
    if!;      %.. for summary output for DISP or BS  estimation
   if!;       % Ending auxiliary if(splitBScod>0.5)
  for!;       % Ending z1 loop over two output pages (if two pages exist)


  % BS-DISP: classify true values versus population of conf-intervals
  % -----------------------------------------------------------------
  if> (errestmode<-2.5 & simu>0); 
    fi=40; ##8='(/A11,2X)';
    write fi, '(//A)', '  Classification of true values vs. confidence intervals';
    write fi, '(/A)',  '  0.0 indicates that true value is < all CI low ends',
                       '  100.0 --> true is > all CI high ends',
                       '  d and 100.0-d  --> true is contained in 2*d % of all CIs',
                       '  Example: 40 or 60 mean that true is contained in 80 CIs out of 100';
    if> (dispbsOKn<5);
      write fi, '(/A)',  '  There are less than 5 accepted resamples.',
                         '  Classification is not attempted at all.';
    else;                       
      for> dl=1:1:dispdqlevs; 
        write fi, ##8, DISPDQHEAD[dl,1];                        
        for> j2=1:1:n2+acbmodel;
          write fi, '(/I6)', j2;
          for> jp=1:1:np;
            id=Classify{TRUEBBCC[j2,jp],BSDISPRES[j2,jp,dl,0,2],0};
            id=100*id/dispbsOKn;         % scale with # of OK resamples
            write fi, '(2X,F5.1)', id;
          for!;
        for!;          
      for!;
    if!;
  if!;
  write 40, '(/)';
  
% Postprocessing, last task: Update status file 15, close other files
% -------------------------------------------------------------------
  ee=1;
  while> (ee~=0); 
    openfile 15, 'pmfstatus.txt', W, 'replace', 200, ee;
    if> (ee~=0); sleep 1;   % Wait one second if file could not be opened
    if!;
  while!;
  closefile 40; closefile 41;
  closefile 49; closefile 51;
  if> (stopped);  write 15, '(1X,A9)', 'PMFstop#1';
  else;           write 15, '(1X,A9)', 'PMF=ready';
  if!;
  write 15, '(I10)', taskxcount, itercount;
  write 15, '(E15.6)', qvalue;
  closefile 15;
  if> (gui>0.5);             % If running under GUI,
    closefile 14, delete;    % delete iniparams.txt, indicating normal end 
  else;
    closefile 14;   %Not GUI: do not delete iniparams.txt
  if!;
if!;    % Ending operations for the last task

section!;  %%%%%%%%%%% end of post-processing section %%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section> callback;

% 
if> (dispgracut>0 );
  if> (Abs{BBCC.fgrad[dispj2,dispjp]} < dispgracut); 
    dispgracnt=dispgracnt+1;
    if> (dispgracnt>4);
 %     finish 'iteration terminated because of repeated small gradient';
      finish ' ';         % Suppress message from .log file
      endingnow=4;        % Indicate to GUI that this is a good solution
    if!;
  else; dispgracnt=0;
  if!;
if!;

% Callback: Compute new pulling anchors FPEAKPULL for FPEAK pulling
% -----------------------------------------------------------------
if> (dofpeak>0.01);                % using AATAA for temporary storage
 % Update FPEAKPULL Data values so that they correspond to current AA values
   Mmtxm{AATAA,AA,AA};             % Compute AA'AA, then inv(AA'AA)
   Mminv{AATAA,AATAA,0.0,0.005};   %   parameters: {inv, matr, tol, reg}
   Mmxm{AATAA,AATAA,FPEAK};        % inv(AA'AA)*FPEAK
   Mmxm{FPEAKPULL,AA,AATAA};       % FPEAKPULL = AA * inv(AA'*AA) * FPEAK
   Blincomb{FPEAKPULL[0,0],150.0,FPEAKPULL[0,0],1.0,AA[0,0]};
   % The scaling coefficient (150.0) has no other significance except that
   % it sets the scale of FPEAK values. This value was chosen because it
   % leads to convenient FPEAK values near +-1.0 for the GE test case.
if!;                     % FPEAKPULL = AA + 150 * AA * inv(AA'*AA) * FPEAK

if> (numrowtyps>1.5 & contrun==0);          % Release downweighting of row types
  if> (Arrmaxval{ROWDOWNWG[0]}>1.00001);    % Inspect previous downwg coefficients
      % If any one is >1,  subtract 0.2 from them, limit by 1.0 and reweight
    for> j1=1:1:n1;  
      rd=ROWDOWNWG[j1]; 
      if> (rd>1.00001);   % Is there still downweighting of row j1?
        rd=Maxval{rd-0.2,1.0}; ROWDOWNWG[j1]=rd;   % If yes, update weight coefficient
        Blincomb{XX.C1[j1,0],rd,XXC1[j1,0,2]};     %.. and store new weights in C1
        Blincomb{XX.C3[j1,0],rd,XXC3[j1,0,2]};     %.. and C3
      if!;  
    for!;       % This variant does not need the new Bmax function
  if!;
if!;


% Callback: Write a status report for the GUI 
% -------------------------------------------
if> (itercount>statuscnt+100);
  openfile 15, 'pmfstatus.txt', W, 'replace', 200, ee;
  if> (ee==0);                 % file was opened successfully
    write 15, '(1X,A9)', 'PMFstatus';
    write 15, '(I10)', taskxcount, itercount;
    write 15, '(E15.6)', qvalue;
    closefile 15;
    statuscnt=itercount;
  if!;
if!;

% Callback: Process a stop command from the GUI: 
% Presence of file 16 indicates a command to stop the run
% ------------------------------------------------------- 
if> (itercount>stopcnt+30);
  openfile 16, 'pmfstop.txt', R, 'old', 200, ee;
  if> (ee==0);           % stop file is present
    stopped=1;   % will write a different status at postprocessing
    openfile 15, 'pmfstatus.txt', W, 'replace', 200, e0;
    if> (e0==0);        % status file was opened successfully
      write 15, '(1X,A9)', 'PMFstop#1';
      write 15, '(I10)', taskxcount, itercount;
      write 15, '(E15.6)', qvalue;
      closefile 15;
    if!;
    read 16, ' ', sc;      % read stop code sc from the file    
    closefile 16, delete;  % Stop command file is deleted
    if> (sc>0);          % sc=1 or sc=2:  Interrupt run and this task,
                         %.. reject results of the interrupted task
                         
      if> (itercount<200 | sc==1);   %.. if sc=1 or if the task has
        numtasks=taskcount-1;        %.. only run less than 200 steps
        finish 'Run is stopped, results from this task are rejected';
      else;
        numtasks=taskcount; 
        finish 'Run is stopped, results from this task are accepted';
      if!;
    else; 
      closefile 14, delete;
      stop 'Run aborted by the GUI';  % sc=0
    if!;
  if!;
  stopcnt=itercount;
if!;

section!; %%% End of callback section, end of the whole script %%%

